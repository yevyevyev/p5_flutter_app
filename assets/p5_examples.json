[
    {
        "groupName": "Structure",
        "examples": [
            {
                "name": "Comments and Statements",
                "description": "Statements are the elements that make up programs. The \";\" (semi-colon) symbol is used to end statements. It is called the \"statement terminator\". Comments are used for making notes to help people better understand programs. A comment begins with two forward slashes (\"//\").\n\nThis example is ported from the Statements and Comments example on the Processing website",
                "code": " // The createCanvas function is a statement that tells the computer \n\n // how large to make the window.\n\n // Each function statement has zero or more parameters. \n\n // Parameters are data passed into the function\n\n // and are used as values for telling the computer what to do.\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n }\n // The background function is a statement that tells the computer\n\n // which color (or gray value) to make the background of the display window \n function draw() {\n     background(204, 153, 0);\n }"
            },
            {
                "name": "Coordinates",
                "description": "All shapes drawn to the screen have a position that is specified as a coordinate. All coordinates are measured as the distance from the origin in units of pixels. The origin [0, 0] is the coordinate in the upper left of the window and the coordinate in the lower right is [width-1, height-1].",
                "code": " function setup() {\n     // Sets the screen to be 720 pixels wide and 400 pixels high\n     createCanvas(screenWidth, screenHeight);\n }\n\n function draw() {\n     // Set the background to black and turn off the fill color\n     background(0);\n     noFill();\n     // The two parameters of the point() method each specify\n\n     // coordinates.\n\n     // The first parameter is the x-coordinate and the second is the Y\n     stroke(255);\n     point(width * 0.5, height * 0.5);\n     point(width * 0.5, height * 0.25);\n     // Coordinates are used for drawing all shapes, not just points.\n\n     // Parameters for different functions are used for different\n\n     // purposes. For example, the first two parameters to line()\n\n     // specify the coordinates of the first endpoint and the second\n\n     // two parameters specify the second endpoint\n     stroke(0, 153, 255);\n     line(0, height * 0.33, width, height * 0.33);\n     // By default, the first two parameters to rect() are the\n\n     // coordinates of the upper-left corner and the second pair\n\n     // is the width and height\n     stroke(255, 153, 0);\n     rect(width * 0.25, height * 0.1, width * 0.5, height * 0.8);\n }"
            },
            {
                "name": "Width and Height",
                "description": "The 'width' and 'height' variables contain the width and height of the display window as defined in the createCanvas() function.",
                "code": " function setup() {\n     createCanvas(screenWidth, screenHeight);\n }\n\n function draw() {\n     background(127);\n     noStroke();\n     for (let i = 0; i < height; i += 20) {\n         fill(129, 206, 15);\n         rect(0, i, width, 10);\n         fill(255);\n         rect(i, 0, 10, height);\n     }\n }"
            },
            {
                "name": "Setup and Draw",
                "description": "The code inside the draw() function runs continuously from top to bottom until the program is stopped. The code in setup() is run once when the program starts.",
                "code": " let y = 100;\n // The statements in the setup() function\n\n // execute once when the program begins\n function setup() {\n     // createCanvas must be the first statement\n     createCanvas(screenWidth, screenHeight);\n     stroke(255);\n     // Set line drawing color to white\n     frameRate(30);\n }\n // The statements in draw() are executed until the\n\n // program is stopped. Each statement is executed in\n\n // sequence and after the last line is read, the first\n\n // line is executed again.\n function draw() {\n     background(0);\n     // Set the background to black\n     y = y - 1;\n     if (y < 0) {\n         y = height;\n     }\n     line(0, y, width, y);\n }"
            },
            {
                "name": "No Loop",
                "description": "The noLoop() function causes draw() to only execute once. Without calling noLoop(), the code inside draw() is run continually.",
                "code": " let y;\n // The statements in the setup() function\n\n // execute once when the program begins\n function setup() {\n     // createCanvas should be the first statement\n     createCanvas(screenWidth, screenHeight);\n     stroke(255);\n     // Set line drawing color to white\n     noLoop();\n     y = height * 0.5;\n }\n // The statements in draw() are executed until the\n\n // program is stopped. Each statement is executed in\n\n // sequence and after the last line is read, the first\n\n // line is executed again.\n function draw() {\n     background(0);\n     // Set the background to black\n     y = y - 1;\n     if (y < 0) {\n         y = height;\n     }\n     line(0, y, width, y);\n }"
            },
            {
                "name": "Loop",
                "description": "If noLoop() is run in setup(), the code in draw() is only run once. In this example, click the mouse to run the loop() function to cause the draw() the run continuously.",
                "code": " let y = 0;\n // The statements in the setup() function\n\n // execute once when the program begins\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     // Size must be the first statement\n     stroke(255);\n     // Set line drawing color to white\n     frameRate(30);\n     noLoop();\n }\n // The statements in draw() are executed until the\n\n // program is stopped. Each statement is executed in\n\n // sequence and after the last line is read, the first\n\n // line is executed again.\n function draw() {\n     background(0);\n     // Set the background to black\n     y = y - 1;\n     if (y < 0) {\n         y = height;\n     }\n     line(0, y, width, y);\n }\n\n function mousePressed() {\n     loop();\n }"
            },
            {
                "name": "Redraw",
                "description": "The redraw() function makes draw() execute once. In this example, draw() is executed once every time the mouse is clicked.",
                "code": " let y;\n // The statements in the setup() function\n\n // execute once when the program begins\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     stroke(255);\n     noLoop();\n     y = height * 0.5;\n }\n // The statements in draw() are executed until the\n\n // program is stopped. Each statement is executed in\n\n // sequence and after the last line is read, the first\n\n // line is executed again.\n function draw() {\n     background(0);\n     y = y - 4;\n     if (y < 0) {\n         y = height;\n     }\n     line(0, y, width, y);\n }\n\n function mousePressed() {\n     redraw();\n }"
            },
            {
                "name": "Functions",
                "description": "The drawTarget() function makes it easy to draw many distinct *targets. Each call to drawTarget() specifies the position, size, and number of *rings for each target.",
                "code": " function setup() {\n     createCanvas(screenWidth, screenHeight);\n     background(51);\n     noStroke();\n     noLoop();\n }\n\n function draw() {\n     drawTarget(width * 0.25, height * 0.4, 200, 4);\n     drawTarget(width * 0.5, height * 0.5, 300, 10);\n     drawTarget(width * 0.75, height * 0.3, 120, 6);\n }\n\n function drawTarget(xloc, yloc, size, num) {\n     const grayvalues = 255 / num;\n     const steps = size / num;\n     for (let i = 0; i < num; i++) {\n         fill(i * grayvalues);\n         ellipse(xloc, yloc, size - i * steps, size - i * steps);\n     }\n }"
            },
            {
                "name": "Recursion",
                "description": "A demonstration of recursion, which means functions call themselves. A recursive function must have a terminating condition, without which it will go into an infinite loop. Notice how the drawCircle() function calls itself at the end of its block. It continues to do this until the variable \"level\" is equal to 1.",
                "code": " function setup() {\n     createCanvas(screenWidth, screenHeight);\n     noStroke();\n     noLoop();\n }\n\n function draw() {\n     drawCircle(width / 2, 280, 6);\n }\n\n function drawCircle(x, radius, level) {\n     // 'level' is the variable that terminates the recursion once it reaches \n\n     // a certain value (here, 1). If a terminating condition is not \n\n     // specified, a recursive function keeps calling itself again and again\n\n     // until it runs out of stack space - not a favourable outcome! \n     const tt = (126 * level) / 4.0;\n     fill(tt);\n     ellipse(x, height / 2, radius * 2, radius * 2);\n     if (level > 1) {\n         // 'level' decreases by 1 at every step and thus makes the terminating condition\n\n         // attainable\n         level = level - 1;\n         drawCircle(x - radius / 2, radius / 2, level);\n         drawCircle(x + radius / 2, radius / 2, level);\n     }\n }"
            },
            {
                "name": "Create Graphics",
                "description": "Creates and returns a new p5.Renderer object. Use this class if you need to draw into an off-screen graphics buffer. The two parameters define the width and height in pixels.",
                "code": " let pg;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     pg = createGraphics(400, 250);\n }\n\n function draw() {\n     fill(0, 12);\n     rect(0, 0, width, height);\n     fill(255);\n     noStroke();\n     ellipse(mouseX, mouseY, 60, 60);\n     pg.background(51);\n     pg.noFill();\n     pg.stroke(255);\n     pg.ellipse(mouseX - 150, mouseY - 75, 60, 60);\n     //Draw the offscreen buffer to the screen with image()\n     image(pg, 150, 75);\n }"
            }
        ]
    },
    {
        "groupName": "Form",
        "examples": [
            {
                "name": "Points and Lines",
                "description": "Points and lines can be used to draw basic geometry. Change the value of the variable 'd' to scale the form. The four variables set the positions based on the value of 'd'.",
                "code": " function setup() {\n     let d = 70;\n     let p1 = d;\n     let p2 = p1 + d;\n     let p3 = p2 + d;\n     let p4 = p3 + d;\n     // Sets the screen to be 720 pixels wide and 400 pixels high\n     createCanvas(screenWidth, screenHeight);\n     background(0);\n     noSmooth();\n     translate(140, 0);\n     // Draw gray box\n     stroke(153);\n     line(p3, p3, p2, p3);\n     line(p2, p3, p2, p2);\n     line(p2, p2, p3, p2);\n     line(p3, p2, p3, p3);\n     // Draw white points\n     stroke(255);\n     point(p1, p1);\n     point(p1, p3);\n     point(p2, p4);\n     point(p3, p1);\n     point(p4, p2);\n     point(p4, p4);\n }"
            },
            {
                "name": "Shape Primitives",
                "description": "The basic shape primitive functions are triangle(), rect(), quad(), ellipse(), and arc(). Squares are made with rect() and circles are made with ellipse(). Each of these functions requires a number of parameters to determine the shape's position and size.",
                "code": " function setup() {\n     // Sets the screen to be 720 pixels wide and 400 pixels high\n     createCanvas(screenWidth, screenHeight);\n     background(0);\n     noStroke();\n     fill(204);\n     triangle(18, 18, 18, 360, 81, 360);\n     fill(102);\n     rect(81, 81, 63, 63);\n     fill(204);\n     quad(189, 18, 216, 18, 216, 360, 144, 360);\n     fill(255);\n     ellipse(252, 144, 72, 72);\n     fill(204);\n     triangle(288, 18, 351, 360, 288, 360);\n     fill(255);\n     arc(479, 300, 280, 280, PI, TWO_PI);\n }"
            },
            {
                "name": "Pie Chart",
                "description": "Uses the arc() function to generate a pie chart from the data stored in an array.",
                "code": " let angles = [30, 10, 45, 35, 60, 38, 75, 67];\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     noStroke();\n     noLoop();\n     // Run once and stop\n }\n\n function draw() {\n     background(100);\n     pieChart(300, angles);\n }\n\n function pieChart(diameter, data) {\n     let lastAngle = 0;\n     for (let i = 0; i < data.length; i++) {\n         let gray = map(i, 0, data.length, 0, 255);\n         fill(gray);\n         arc(width / 2, height / 2, diameter, diameter, lastAngle, lastAngle + radians(angles[i]));\n         lastAngle += radians(angles[i]);\n     }\n }"
            },
            {
                "name": "Regular Polygon",
                "description": "What is your favorite? Pentagon? Hexagon? Heptagon? No? What about the icosagon? The polygon() function created for this example is capable of drawing any regular polygon. Try placing different numbers into the polygon() function calls within draw() to explore.",
                "code": " function setup() {\n     createCanvas(screenWidth, screenHeight);\n }\n\n function draw() {\n     background(102);\n     push();\n     translate(width * 0.2, height * 0.5);\n     rotate(frameCount / 200.0);\n     polygon(0, 0, 82, 3);\n     pop();\n     push();\n     translate(width * 0.5, height * 0.5);\n     rotate(frameCount / 50.0);\n     polygon(0, 0, 80, 20);\n     pop();\n     push();\n     translate(width * 0.8, height * 0.5);\n     rotate(frameCount / -100.0);\n     polygon(0, 0, 70, 7);\n     pop();\n }\n\n function polygon(x, y, radius, npoints) {\n     let angle = TWO_PI / npoints;\n     beginShape();\n     for (let a = 0; a < TWO_PI; a += angle) {\n         let sx = x + cos(a) * radius;\n         let sy = y + sin(a) * radius;\n         vertex(sx, sy);\n     }\n     endShape(CLOSE);\n }"
            },
            {
                "name": "Star",
                "description": "The star() function created for this example is capable of drawing a wide range of different forms. Try placing different numbers into the star() function calls within draw() to explore.",
                "code": " function setup() {\n     createCanvas(screenWidth, screenHeight);\n }\n\n function draw() {\n     background(102);\n     push();\n     translate(width * 0.2, height * 0.5);\n     rotate(frameCount / 200.0);\n     star(0, 0, 5, 70, 3);\n     pop();\n     push();\n     translate(width * 0.5, height * 0.5);\n     rotate(frameCount / 50.0);\n     star(0, 0, 80, 100, 40);\n     pop();\n     push();\n     translate(width * 0.8, height * 0.5);\n     rotate(frameCount / -100.0);\n     star(0, 0, 30, 70, 5);\n     pop();\n }\n\n function star(x, y, radius1, radius2, npoints) {\n     let angle = TWO_PI / npoints;\n     let halfAngle = angle / 2.0;\n     beginShape();\n     for (let a = 0; a < TWO_PI; a += angle) {\n         let sx = x + cos(a) * radius2;\n         let sy = y + sin(a) * radius2;\n         vertex(sx, sy);\n         sx = x + cos(a + halfAngle) * radius1;\n         sy = y + sin(a + halfAngle) * radius1;\n         vertex(sx, sy);\n     }\n     endShape(CLOSE);\n }"
            },
            {
                "name": "Triangle Strip",
                "description": "Example by Ira Greenberg. Generate a closed ring using the vertex() function and beginShape(TRIANGLE_STRIP) mode. The outsideRadius and insideRadius variables control ring's radii respectively.",
                "code": " let x;\n let y;\n let outsideRadius = 150;\n let insideRadius = 100;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     background(204);\n     x = width / 2;\n     y = height / 2;\n }\n\n function draw() {\n     background(204);\n     let numPoints = int(map(mouseX, 0, width, 6, 60));\n     let angle = 0;\n     let angleStep = 180.0 / numPoints;\n     beginShape(TRIANGLE_STRIP);\n     for (let i = 0; i <= numPoints; i++) {\n         let px = x + cos(radians(angle)) * outsideRadius;\n         let py = y + sin(radians(angle)) * outsideRadius;\n         angle += angleStep;\n         vertex(px, py);\n         px = x + cos(radians(angle)) * insideRadius;\n         py = y + sin(radians(angle)) * insideRadius;\n         vertex(px, py);\n         angle += angleStep;\n     }\n     endShape();\n }"
            },
            {
                "name": "Bezier",
                "description": "The first two parameters for the bezier() function specify the first point in the curve and the last two parameters specify the last point. The middle parameters set the control points that define the shape of the curve.",
                "code": " function setup() {\n     createCanvas(screenWidth, screenHeight);\n     stroke(255);\n     noFill();\n }\n\n function draw() {\n     background(0);\n     for (let i = 0; i < 200; i += 20) {\n         bezier(mouseX - i / 2.0, 40 + i, 410, 20, 440, 300, 240 - i / 16.0, 300 + i / 8.0);\n     }\n }"
            },
            {
                "name": "3D Primitives",
                "description": "Placing mathematically 3D objects in synthetic space. The box() and sphere() functions take at least one parameter to specify their size. These shapes are positioned using the translate() function.",
                "code": " function setup() {\n     createCanvas(screenWidth, screenHeight, WEBGL);\n }\n\n function draw() {\n     background(100);\n     noStroke();\n     fill(50);\n     push();\n     translate(-275, 175);\n     rotateY(1.25);\n     rotateX(-0.9);\n     box(100);\n     pop();\n     noFill();\n     stroke(255);\n     push();\n     translate(500, height * 0.35, -200);\n     sphere(300);\n     pop();\n }"
            },
            {
                "name": "Trig Wheels and Pie Chart",
                "description": "contributed by Prof WM Harris, How to create a trig color wheel and a visualization of a population age data as a pie chart.\nFunctions are created for the canvas setup, trig color wheel, drawslice, and pie chart. The size of the slices are determined as well as their color range. The pie chart is separated by definitive color per value whereas the trig color wheel has a fixed slice amount with a range color fill.",
                "code": " function setup() {\n     createCanvas(screenWidth, screenHeight);\n     colorMode(HSB);\n     angleMode(DEGREES);\n     //vars for color wheel center point\n     let x = width / 2;\n     let y = height / 2 + 100;\n     colorWheel(x, y, 100);\n     //slide 11\n     noStroke();\n     pieChartPop(200, 100);\n     //slide 12\n }\n //**** slide 12 pie chart trig demo \n function pieChartPop(x, y) {\n     let [total, child, young, adult, senior, elder] = [577, 103, 69, 122, 170, 113];\n     let startValue = 0;\n     let range = 0;\n     //child slice\n     range = child / total;\n     drawSlice(\"blue\", x, y, 200, startValue, startValue + range);\n     startValue += range;\n     //young slice\n     range = young / total;\n     drawSlice(\"orange\", x, y, 200, startValue, startValue + range);\n     startValue += range;\n     //adult slice\n     range = adult / total;\n     drawSlice(\"green\", x, y, 200, startValue, startValue + range);\n     startValue += range;\n     //senior slice\n     range = senior / total;\n     drawSlice(\"tan\", x, y, 200, startValue, startValue + range);\n     startValue += range;\n     //elder slice\n     range = elder / total;\n     drawSlice(\"pink\", x, y, 200, startValue, startValue + range);\n     startValue += range;\n }\n /**\n  \n  * drawSlice - draw colored arc based on angle percentages. slide 13\n  \n  * Adjust angles so that 0% starts at top (actually -90).\n  \n  * \n  \n @param\n  \n  {color} fColor - fill color\n  \n  * \n  \n @param\n  \n  {number} x - center x\n  \n  * \n  \n @param\n  \n  {number} y - center y\n  \n  * \n  \n @param\n  \n  {number} d - diameter\n  \n  * \n  \n @param\n  \n  {float} percent1 - starting percentage\n  \n  * \n  \n @param\n  \n  {float} percent2 - ending percentage\n  \n  */\n function drawSlice(fColor, x, y, d, percent1, percent2) {\n     fill(fColor);\n     arc(x, y, d, d, -90 + percent1 * 360, -90 + percent2 * 360);\n }\n //**** slide 11 trig demo \n function colorWheel(x, y, rad) {\n     strokeWeight(10);\n     strokeCap(SQUARE);\n     //Iterate 360 degrees of lines, +10deg per turn\n     for (let a = 0; a < 360; a += 10) {\n         stroke(a, 150, 200);\n         //hue based on a\n\n         //radius is 100, angle is a degrees\n         line(x, y, x + rad * cos(a), y + rad * sin(a));\n     }\n }"
            }
        ]
    },
    {
        "groupName": "Data",
        "examples": [
            {
                "name": "Variables",
                "description": "Variables are used for storing values. In this example, change the values of variables to affect the composition.",
                "code": " function setup() {\n     createCanvas(screenWidth, screenHeight);\n     background(0);\n     stroke(153);\n     strokeWeight(4);\n     strokeCap(SQUARE);\n     let a = 50;\n     let b = 120;\n     let c = 180;\n     line(a, b, a + c, b);\n     line(a, b + 10, a + c, b + 10);\n     line(a, b + 20, a + c, b + 20);\n     line(a, b + 30, a + c, b + 30);\n     a = a + c;\n     b = height - b;\n     line(a, b, a + c, b);\n     line(a, b + 10, a + c, b + 10);\n     line(a, b + 20, a + c, b + 20);\n     line(a, b + 30, a + c, b + 30);\n     a = a + c;\n     b = height - b;\n     line(a, b, a + c, b);\n     line(a, b + 10, a + c, b + 10);\n     line(a, b + 20, a + c, b + 20);\n     line(a, b + 30, a + c, b + 30);\n }"
            },
            {
                "name": "True and False",
                "description": "A Boolean variable has only two possible values: true or false. It is common to use Booleans with control statements to determine the flow of a program. In this example, when the boolean value \"b\" is true, vertical lines are drawn and when the boolean value \"b\" is false, horizontal lines are drawn.",
                "code": " function setup() {\n     createCanvas(screenWidth, screenHeight);\n     background(0);\n     stroke(255);\n     let b = false;\n     let d = 20;\n     let middle = width / 2;\n     for (let i = d; i <= width; i += d) {\n         b = i < middle;\n         if (b === true) {\n             // Vertical line\n             line(i, d, i, height - d);\n         }\n         if (b === false) {\n             // Horizontal line\n             line(middle, i - middle + d, width - d, i - middle + d);\n         }\n     }\n }"
            },
            {
                "name": "Variable Scope",
                "description": "Variables have a global or function \"scope\". For example, variables declared within either the setup() or draw() functions may be only used in these functions. Global variables, variables declared outside of setup() and draw(), may be used anywhere within the program. If a function variable is declared with the same name as a global variable, the program will use the function variable to make its calculations within the current scope.",
                "code": " let a = 80;\n // Create a global variable \"a\"\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     background(0);\n     stroke(255);\n     noLoop();\n }\n\n function draw() {\n     // Draw a line using the global variable \"a\"\n     line(a, 0, a, height);\n     // Use a local variable a in for loop\n     for (let a = 120; a < 200; a += 3) {\n         line(a, 0, a, height);\n     }\n     // Make a call to the custom function drawAnotherLine()\n     drawAnotherLine();\n     // Make a call to the custom function drawYetAnotherLine()\n     drawYetAnotherLine();\n }\n\n function drawAnotherLine() {\n     // Create a new variable \"a\" local to this function\n     let a = 320;\n     // Draw a line using the local variable \"a\"\n     line(a, 0, a, height);\n }\n\n function drawYetAnotherLine() {\n     // Because no new local variable \"a\" is set,\n\n     // this line draws using the original global\n\n     // variable \"a\" which is set to the value 20.\n     line(a + 3, 0, a + 3, height);\n }"
            },
            {
                "name": "Numbers",
                "description": "Numbers can be written with or without decimals. An integer (more commonly called an int) is a number without a decimal point. A float is a floating-point number, which means it is a number that has a decimal place.",
                "code": " let a = 0;\n // Create a global variable \"a\" of type Number\n let b = 0;\n // Create a global variable \"b\" of type Number\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     stroke(255);\n }\n\n function draw() {\n     background(0);\n     a = a + 1;\n     // Increment a with an integer\n     b = b + 0.2;\n     //Increment b with a float\n     line(a, 0, a, height / 2);\n     line(b, height / 2, b, height);\n     if (a > width) {\n         a = 0;\n     }\n     if (b > width) {\n         b = 0;\n     }\n }"
            }
        ]
    },
    {
        "groupName": "Arrays",
        "examples": [
            {
                "name": "Array",
                "description": "An array is a list of data. Each piece of data in an array is identified by an index number representing its position in the array. Arrays are zero based, which means that the first element in the array is [0], the second element is [1], and so on. In this example, an array named \"coswave\" is created and filled with the cosine values. This data is displayed three separate ways on the screen.",
                "code": " let coswave = [];\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     for (let i = 0; i < width; i++) {\n         let amount = map(i, 0, width, 0, PI);\n         coswave[i] = abs(cos(amount));\n     }\n     background(255);\n     noLoop();\n }\n\n function draw() {\n     let y1 = 0;\n     let y2 = height / 3;\n     for (let i = 0; i < width; i += 3) {\n         stroke(coswave[i] * 255);\n         line(i, y1, i, y2);\n     }\n     y1 = y2;\n     y2 = y1 + y1;\n     for (let i = 0; i < width; i += 3) {\n         stroke((coswave[i] * 255) / 4);\n         line(i, y1, i, y2);\n     }\n     y1 = y2;\n     y2 = height;\n     for (let i = 0; i < width; i += 3) {\n         stroke(255 - coswave[i] * 255);\n         line(i, y1, i, y2);\n     }\n }"
            },
            {
                "name": "Array 2D",
                "description": "Demonstrates the syntax for creating a two-dimensional (2D) array. Values in a 2D array are accessed through two index values. 2D arrays are useful for storing images. In this example, each dot is colored in relation to its distance from the center of the image.",
                "code": " let distances = [];\n let maxDistance;\n let spacer;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     maxDistance = dist(width / 2, height / 2, width, height);\n     for (let x = 0; x < width; x++) {\n         distances[x] = [];\n         // create nested array\n         for (let y = 0; y < height; y++) {\n             let distance = dist(width / 2, height / 2, x, y);\n             distances[x][y] = (distance / maxDistance) * 255;\n         }\n     }\n     spacer = 10;\n     noLoop();\n     // Run once and stop\n }\n\n function draw() {\n     background(0);\n     // This embedded loop skips over values in the arrays based on\n\n     // the spacer variable, so there are more values in the array\n\n     // than are drawn here. Change the value of the spacer variable\n\n     // to change the density of the points\n     for (let x = 0; x < width; x += spacer) {\n         for (let y = 0; y < height; y += spacer) {\n             stroke(distances[x][y]);\n             point(x + spacer / 2, y + spacer / 2);\n         }\n     }\n }"
            },
            {
                "name": "Array Objects",
                "description": "Demonstrates the syntax for creating an array of custom objects.",
                "code": " class Module {\n     constructor(xOff, yOff, x, y, speed, unit) {\n         this.xOff = xOff;\n         this.yOff = yOff;\n         this.x = x;\n         this.y = y;\n         this.speed = speed;\n         this.unit = unit;\n         this.xDir = 1;\n         this.yDir = 1;\n     }\n     // Custom method for updating the variables\n     update() {\n         this.x = this.x + this.speed * this.xDir;\n         if (this.x >= this.unit || this.x <= 0) {\n             this.xDir *= -1;\n             this.x = this.x + 1 * this.xDir;\n             this.y = this.y + 1 * this.yDir;\n         }\n         if (this.y >= this.unit || this.y <= 0) {\n             this.yDir *= -1;\n             this.y = this.y + 1 * this.yDir;\n         }\n     }\n     // Custom method for drawing the object\n     draw() {\n         fill(255);\n         ellipse(this.xOff + this.x, this.yOff + this.y, 6, 6);\n     }\n }\n let unit = 40;\n let count;\n let mods = [];\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     noStroke();\n     let wideCount = width / unit;\n     let highCount = height / unit;\n     count = wideCount * highCount;\n     let index = 0;\n     for (let y = 0; y < highCount; y++) {\n         for (let x = 0; x < wideCount; x++) {\n             mods[index++] = new Module(x * unit, y * unit, unit / 2, unit / 2, random(0.05, 0.8), unit);\n         }\n     }\n }\n\n function draw() {\n     background(0);\n     for (let i = 0; i < count; i++) {\n         mods[i].update();\n         mods[i].draw();\n     }\n }"
            },
            {
                "name": "Walk Over 2dArray",
                "description": "contributed by Prof WM Harris, How to display 2D array contents on the canvas using regular for and for-of loops in multiple different ways.\nA function is created for the canvas, the 2D array (Friend Array) is initialized and walked over using nested loops in different ways. Variables x and y are used to place the array item on the canvas in the form of 2D array. The final nested loop is used to initialize 2D array (Fish Array) with random Integers (fish ages).",
                "code": " //\"use strict\"; //catch some common coding errors\n\n /**\n  \n  * setup :\n  \n  */\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     //create 2D array, slide 4\n     let friendArray = [\n         [\"Nona\", \"mac & cheese\", \"orange\", \"Eid al-fitr\"],\n         [\"Marylin\", \"ice cream\", \"blue\", \"Halloween\"],\n         [\"Rashaad\", \"garbage plates\", \"turquoise\", \"Christmas\"],\n         [\"Ava\", \"sushi\", \"pink\", \"New Years\"]\n     ];\n     friendArray.push([\"Xavier\", \"Louisiana creole\", \"red\", \"their birthday\"]);\n     //walking 2D array, slide 6\n     let y = 20;\n     // Start row based on text size of 20\n     for (let f = 0; f < friendArray.length; f++) {\n         // outer array\n         let x = 10;\n         // Start item in this row\n         for (let t = 0; t < friendArray[f].length; t++) {\n             //inner\n             text(friendArray[f][t], x, y);\n             x += textWidth(friendArray[f][t]) + 20;\n             //place next item\n         }\n         y += 28;\n         // place next row\n     }\n     //walking 2D array, variation on slide 6\n\n     //with embedded arithmetic for y\n\n     //\n     for (let f = 0; f < friendArray.length; f++) {\n         // outer array\n         let x = 10;\n         // Start item in this row\n         for (let t = 0; t < friendArray[f].length; t++) {\n             //inner\n\n             //y is v-padding + LCV * v-spacing\n             text(friendArray[f][t], x, 200 + f * 28);\n             x += textWidth(friendArray[f][t]) + 20;\n             //place next item\n         }\n     }\n     //walking 2D array, slide 7\n\n     //need to use x and y variables to manage canvas placement\n     y = 400;\n     for (let friend of friendArray) {\n         let x = 10;\n         // Start item in this row\n         console.log(\"x and y\", x, y);\n         console.log(\"friend:\", friend);\n         for (let item of friend) {\n             console.log(\"item & x:\", item, x);\n             text(item, x, y);\n             x += textWidth(item) + 20;\n             //place next item\n         }\n         y += 28;\n         // place next row \n     }\n     //slide 9, creating 2D array: schools of fish ages\n     console.log(\" \\n  *** Fish ages in 2D ***\");\n     const schools = [];\n     //4 schools of fish\n     for (let t = 0; t < 4; t++) {\n         schools[t] = [];\n         //initialize this school \n         console.log(\"schools[t]?\", t, schools[t]);\n         // Add 10 randomized ages to the array\n         for (let a = 0; a < 10; a++) {\n             schools[t].push(round(random(1, 5)));\n         }\n     }\n     console.log(schools);\n }"
            }
        ]
    },
    {
        "groupName": "Control",
        "examples": [
            {
                "name": "Iteration",
                "description": "Iteration with a \"for\" structure to construct repetitive forms.",
                "code": " let y;\n let num = 14;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     background(102);\n     noStroke();\n     // Draw white bars\n     fill(255);\n     y = 60;\n     for (let i = 0; i < num / 3; i++) {\n         rect(50, y, 475, 10);\n         y += 20;\n     }\n     // Gray bars\n     fill(51);\n     y = 40;\n     for (let i = 0; i < num; i++) {\n         rect(405, y, 30, 10);\n         y += 20;\n     }\n     y = 50;\n     for (let i = 0; i < num; i++) {\n         rect(425, y, 30, 10);\n         y += 20;\n     }\n     // Thin lines\n     y = 45;\n     fill(0);\n     for (let i = 0; i < num - 1; i++) {\n         rect(120, y, 40, 1);\n         y += 20;\n     }\n }"
            },
            {
                "name": "Embedded Iteration",
                "description": "Embedding \"for\" structures allows repetition in two dimensions.",
                "code": " function setup() {\n     createCanvas(screenWidth, screenHeight);\n     background(0);\n     noStroke();\n     let gridSize = 35;\n     for (let x = gridSize; x <= width - gridSize; x += gridSize) {\n         for (let y = gridSize; y <= height - gridSize; y += gridSize) {\n             noStroke();\n             fill(255);\n             rect(x - 1, y - 1, 3, 3);\n             stroke(255, 50);\n             line(x, y, width / 2, height / 2);\n         }\n     }\n }"
            },
            {
                "name": "Conditionals 1",
                "description": "Conditions are like questions. They allow a program to decide to take one action if the answer to a question is true or to do another action if the answer to the question is false. The questions asked within a program are always logical or relational statements. For example, if the variable 'i' is equal to zero then draw a line.",
                "code": " function setup() {\n     createCanvas(screenWidth, screenHeight);\n     background(0);\n     for (let i = 10; i < width; i += 10) {\n         // If 'i' divides by 20 with no remainder draw the first line\n\n         // else draw the second line\n         if (i % 20 === 0) {\n             stroke(255);\n             line(i, 80, i, height / 2);\n         } else {\n             stroke(153);\n             line(i, 20, i, 180);\n         }\n     }\n }"
            },
            {
                "name": "Conditionals 2",
                "description": "We extend the language of conditionals from the previous example by adding the keyword \"else\". This allows conditionals to ask two or more sequential questions, each with a different action.",
                "code": " function setup() {\n     createCanvas(screenWidth, screenHeight);\n     background(0);\n     for (let i = 2; i < width - 2; i += 4) {\n         // If 'i' divides by 20 with no remainder\n         if (i % 20 === 0) {\n             stroke(255);\n             line(i, 80, i, height / 2);\n             // If 'i' divides by 10 with no remainder\n         } else if (i % 10 === 0) {\n             stroke(153);\n             line(i, 20, i, 180);\n             // If neither of the above two conditions are met\n\n             // then draw this line\n         } else {\n             stroke(102);\n             line(i, height / 2, i, height - 20);\n         }\n     }\n }"
            },
            {
                "name": "Logical Operators",
                "description": "The logical operators for AND (&&) and OR (||) are used to combine simple relational statements into more complex expressions. The NOT (!) operator is used to negate a boolean statement.",
                "code": " let test = false;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     background(126);\n     for (let i = 5; i <= height; i += 5) {\n         // Logical AND\n         stroke(0);\n         if (i > 35 && i < 100) {\n             line(width / 4, i, width / 2, i);\n             test = false;\n         }\n         // Logical OR\n         stroke(76);\n         if (i <= 35 || i >= 100) {\n             line(width / 2, i, width, i);\n             test = true;\n         }\n         // Testing if a boolean value is \"true\"\n\n         // The expression \"if(test)\" is equivalent to \"if(test == true)\"\n         if (test) {\n             stroke(0);\n             point(width / 3, i);\n         }\n         // Testing if a boolean value is \"false\"\n\n         // The expression \"if(!test)\" is equivalent to \"if(test == false)\"\n         if (!test) {\n             stroke(255);\n             point(width / 4, i);\n         }\n     }\n }"
            },
            {
                "name": "Logical Operators 2",
                "description": "contributed by Prof WM Harris, How to create Xboxes with one global variable and create conditions with boolean variables and boolean expressions by utilizing Boolean operators ||, &&, and ! to do boundary checking.\nFunctions are created for both the canvas set up as well as the creation of the boxes. Background color is dependent on the location of the boxes in the canvas space. When mouse button and key are pressed simultaneously, the “where” text and box color changes to cyan, but if the mouse button is clicked alone then the animation will start. When q or Q are pressed the text “Did you type q or Q?” will change to blue, else it will be purple. If the mouse is placed within the orange box containing the text, “withinRect” then the shape will turn pink.",
                "code": " //1 coordinate for everything :)\n let where = 0;\n //control boxes' positions\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n }\n\n function draw() {\n     //similar to slide 4 use of OR, ||\n\n     //to set bg color of canvas\n     if ((where < 0) || (where > height)) {\n         background(\"beige\");\n     } else {\n         background(\"chocolate\");\n     }\n     //similar to slide 4 use of AND, &&\n\n     //to set fill color of box & text\n     if (mouseIsPressed && keyIsPressed) {\n         fill(\"cyan\");\n     } else {\n         fill(255);\n     }\n     //boxL\n     rect(where, where, 40);\n     //boxR, pad x coordinate for size of box\n     rect(width - where - 40, where, 40);\n     //Move the boxes\n     where = where + 1;\n     //Show the value of where the boxes are\n     text(\"where is \" + where, 150, 30);\n     //testing not, ! and or, || operators\n     if (!(key === \"q\" || key === \"Q\")) {\n         fill(\"purple\");\n     } else {\n         fill(\"dodgerBlue\");\n     }\n     //Show the current key value\n     text(\"Did you type a q or Q? \" + key, 150, 70);\n     //*** Boundary checking ***\n\n     //Is the mouse within rect boundary?\n\n     //left, right, top, bottom\n     let withinRect = (mouseX >= 150) && (mouseX <= 150 + 100) && (mouseY >= 300) && (mouseY <= 300 + 40);\n     //fill color based on value of withinRect\n     if (withinRect) {\n         fill(\"pink\");\n     } else {\n         fill(\"orange\");\n     }\n     //draw the rect\n     rect(150, 300, 100, 40);\n     //show withinRect value as label on rect\n     fill(0);\n     text(\"withinRect \" + withinRect, 160, 320);\n }\n //boxes restart\n function mousePressed() {\n     //Reset boxes back up and above the canvas\n     where = -50;\n }"
            },
            {
                "name": "Conditional Shapes",
                "description": "contributed by Prof WM Harris, How to draw different shapes mid canvas depending on the mouse position.\nFunctions are created for the main canvas set up with the markers on the left and right hand sides. One is also created for the location of the mouse regarding the canvas and the markers. If the mouse is within the outer left hand beige rectangle, then the shape of circle is drawn down the center of the canvas. If the mouse is within the outer right hand beige rectangle, then the shape of square is drawn down the center of the canvas.",
                "code": " function setup() {\n     createCanvas(screenWidth, screenHeight);\n     strokeWeight(3);\n     //center squares to match circles\n     rectMode(CENTER);\n     //draw rects to mark far sides\n     noStroke();\n     fill(\"beige\");\n     rect(5, height / 2, 10, height);\n     rect(width - 5, height / 2, 10, height);\n     fill(\"orange\");\n     stroke(\"brown\");\n }\n\n function draw() {\n     point(mouseX, mouseY);\n     //if (test) {doThis; }\n\n     //test: mouseX on far left of canvas\n\n     //doThis: draw a circle at mouseY\n     if (mouseX < 10) {\n         circle(width / 2, mouseY, 20);\n     }\n     //test: mouseX on far right of canvas\n\n     //doThis: draw a square at mouseY\n     if (mouseX > width - 10) {\n         square(width / 2, mouseY, 20);\n     }\n }"
            }
        ]
    },
    {
        "groupName": "Image",
        "examples": [
            {
                "name": "Load and Display Image",
                "description": "Images can be loaded and displayed to the screen at their actual size or any other size.\n\nTo run this example locally, you will need an image file, and a running local server.",
                "code": " let img;\n // Declare variable 'img'.\nfunction preload() {\nconsole.log(\"loading image\");\nimg = loadImage('assets/moonwalk.jpg');\n}\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     // Load the image\n }\n\n function draw() {\n     // Displays the image at its actual size at point (0,0)\n     image(img, 0, 0);\n     // Displays the image at point (0, height/2) at half size\n     image(img, 0, height / 2, img.width / 2, img.height / 2);\n }"
            },
            {
                "name": "Background Image",
                "description": "This example presents the fastest way to load a background image. To load an image as the background, it must be the same width and height as the program.\n\nTo run this example locally, you will need an image file, and a running local server.",
                "code": " let bg;\n let y = 0;\n\n function setup() {\n     // The background image must be the same size as the parameters\n\n     // into the createCanvas() method. In this program, the size of\n\n     // the image is 720x400 pixels.\n     bg = loadImage('assets/moonwalk.jpg');\n     createCanvas(screenWidth, screenHeight);\n }\n\n function draw() {\n     background(bg);\n     stroke(226, 204, 0);\n     line(0, y, width, y);\n     y++;\n     if (y > height) {\n         y = 0;\n     }\n }"
            },
            {
                "name": "Transparency",
                "description": "Move the pointer left and right across the image to change its position. This program overlays one image over another by modifying the alpha value of the image with the tint() function.\n\nTo run this example locally, you will need an image file, and a running local server.",
                "code": " let img;\n let offset = 0;\n let easing = 0.05;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     img = loadImage('assets/moonwalk.jpg');\n     // Load an image into the program\n }\n\n function draw() {\n     image(img, 0, 0);\n     // Display at full opacity\n     let dx = mouseX - img.width / 2 - offset;\n     offset += dx * easing;\n     tint(255, 127);\n     // Display at half opacity\n     image(img, offset, 0);\n }"
            },
            {
                "name": "Alpha Mask",
                "description": "Loads a \"mask\" for an image to specify the transparency in different parts of the image. The two images are blended together using the mask() method of p5.Image.\n\nTo run this example locally, you will need two image files, and a running local server.",
                "code": " let img;\n let imgMask;\n\n function preload() {\n     img = loadImage('assets/moonwalk.jpg');\n     imgMask = loadImage('assets/mask.png');\n }\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     img.mask(imgMask);\n     imageMode(CENTER);\n }\n\n function draw() {\n     background(0, 102, 153);\n     image(img, width / 2, height / 2);\n     image(img, mouseX, mouseY);\n }"
            },
            {
                "name": "Create Image",
                "description": "The createImage() function provides a fresh buffer of pixels to play with. This example creates an image gradient.",
                "code": " let img;\n // Declare variable 'img'.\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     img = createImage(230, 230);\n     img.loadPixels();\n     for (let x = 0; x < img.width; x++) {\n         for (let y = 0; y < img.height; y++) {\n             let a = map(y, 0, img.height, 255, 0);\n             img.set(x, y, [0, 153, 204, a]);\n         }\n     }\n     img.updatePixels();\n }\n\n function draw() {\n     background(0);\n     image(img, 90, 80);\n     image(img, mouseX - img.width / 2, mouseY - img.height / 2);\n }"
            },
            {
                "name": "Pointillism",
                "description": "By Dan Shiffman. Mouse horizontal location controls size of dots. Creates a simple pointillist effect using ellipses colored according to pixels in an image.\n\nTo run this example locally, you will need an image file, and a running local server.",
                "code": " let img;\n let smallPoint, largePoint;\n\n function preload() {\n     img = loadImage('assets/moonwalk.jpg');\n }\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     smallPoint = 4;\n     largePoint = 40;\n     imageMode(CENTER);\n     noStroke();\n     background(255);\n     img.loadPixels();\n }\n\n function draw() {\n     let pointillize = map(mouseX, 0, width, smallPoint, largePoint);\n     let x = floor(random(img.width));\n     let y = floor(random(img.height));\n     let pix = img.get(x, y);\n     fill(pix, 128);\n     ellipse(x, y, pointillize, pointillize);\n }"
            },
            {
                "name": "Blur",
                "description": "A low-pass filter that blurs an image. This program analyzes every pixel in an image and blends it with all the neighboring pixels to blur the image.\n\nThis example is ported from the Blur example on the Processing website",
                "code": " // to consider all neighboring pixels we use a 3x3 array\n\n // and normalize these values\n\n // v is the normalized value\n let v = 1.0 / 9.0;\n // kernel is the 3x3 matrix of normalized values\n let kernel = [\n     [v, v, v],\n     [v, v, v],\n     [v, v, v]\n ];\n // preload() runs once, before setup()\n\n // loadImage() needs to occur here instead of setup()\n\n // if loadImage() is called in setup(), the image won't appear\n\n // since noLoop() restricts draw() to execute only once\n\n // (one execution of draw() is not enough time for the image to load),\n\n // preload() makes sure image is loaded before anything else occurs\n function preload() {\n     // load the original image\n     img = loadImage('assets/rover.png');\n }\n // setup() runs once after preload\n function setup() {\n     // create canvas\n     createCanvas(screenWidth, screenHeight);\n     // noLoop() makes draw() run only once, not in a loop\n     noLoop();\n }\n // draw() runs after setup(), normally on a loop\n\n // in this case it runs only once, because of noDraw()\n function draw() {\n     // place the original image on the upper left corner\n     image(img, 0, 0);\n     // create a new image, same dimensions as img\n     edgeImg = createImage(img.width, img.height);\n     // load its pixels\n     edgeImg.loadPixels();\n     // two for() loops, to iterate in x axis and y axis\n\n     // since the kernel assumes that the pixel\n\n     // has pixels above, under, left, and right\n\n     // we need to skip the first and last column and row\n\n     // x then goes from 1 to width - 1\n\n     // y then goes from 1 to height - 1\n     for (let x = 1; x < img.width; x++) {\n         for (let y = 1; y < img.height; y++) {\n             // kernel sum for the current pixel starts as 0\n             let sum = 0;\n             // kx, ky variables for iterating over the kernel\n\n             // kx, ky have three different values: -1, 0, 1\n             for (kx = -1; kx <= 1; kx++) {\n                 for (ky = -1; ky <= 1; ky++) {\n                     let xpos = x + kx;\n                     let ypos = y + ky;\n                     // since our image is grayscale,\n\n                     // RGB values are identical\n\n                     // we retrieve the red value for this example\n\n                     // (green and blue work as well)\n                     let val = red(img.get(xpos, ypos));\n                     // accumulate the  kernel sum\n\n                     // kernel is a 3x3 matrix\n\n                     // kx and ky have values -1, 0, 1\n\n                     // if we add 1 to kx and ky, we get 0, 1, 2\n\n                     // with that we can use it to iterate over kernel\n\n                     // and calculate the accumulated sum\n                     sum += kernel[kx + 1][ky + 1] * val;\n                 }\n             }\n             // set the value of the edgeImg pixel to the kernel sum\n             edgeImg.set(x, y, color(sum));\n         }\n     }\n     // updatePixels() to write the changes on edgeImg\n     edgeImg.updatePixels();\n     // draw edgeImg at the right of the original image\n     image(edgeImg, img.width, 0);\n }"
            },
            {
                "name": "Edge Detection",
                "description": "A high-pass filter sharpens an image. This program analyzes every pixel in an image in relation to the neighboring pixels to sharpen the image.\n\nThis example is ported from the Edge Detection example on the Processing website",
                "code": " // this program analyzes every pixel in an image\n\n // in relation to the neighbouring pixels\n\n // to sharpen the image\n\n // to consider all neighboring pixels we use a 3x3 array\n\n // and normalize these values\n\n // kernel is the 3x3 matrix of normalized values\n let kernel = [\n     [-1, -1, -1],\n     [-1, 9, -1],\n     [-1, -1, -1]\n ];\n // preload() runs once, before setup()\n\n // loadImage() needs to occur here instead of setup()\n\n // if loadImage() is called in setup(), the image won't appear\n\n // since noLoop() restricts draw() to execute only once\n\n // (one execution of draw() is not enough time for the image to load),\n\n // preload() makes sure image is loaded before anything else occurs\n function preload() {\n     // load the original image\n     img = loadImage('assets/rover.png');\n }\n // setup() runs after preload, once()\n function setup() {\n     // create canvas\n     createCanvas(screenWidth, screenHeight);\n     // noLoop() makes draw() run only once, not in a loop\n     noLoop();\n }\n // draw() runs after setup(), normally on a loop\n\n // in this case it runs only once, because of noDraw()\n function draw() {\n     // place the original image on the upper left corner\n     image(img, 0, 0);\n     // create a new image, same dimensions as img\n     edgeImg = createImage(img.width, img.height);\n     // load its pixels\n     edgeImg.loadPixels();\n     // two for() loops, to iterate in x axis and y axis\n\n     // since the kernel assumes that the pixel\n\n     // has pixels above, under, left, and right\n\n     // we need to skip the first and last column and row\n\n     // x then goes from 1 to width - 1\n\n     // y then goes from 1 to height - 1\n     for (let x = 1; x < img.width - 1; x++) {\n         for (let y = 1; y < img.height - 1; y++) {\n             // kernel sum for the current pixel starts as 0\n             let sum = 0;\n             // kx, ky variables for iterating over the kernel\n\n             // kx, ky have three different values: -1, 0, 1\n             for (kx = -1; kx <= 1; kx++) {\n                 for (ky = -1; ky <= 1; ky++) {\n                     let xpos = x + kx;\n                     let ypos = y + ky;\n                     let pos = (y + ky) * img.width + (x + kx);\n                     // since our image is grayscale,\n\n                     // RGB values are identical\n\n                     // we retrieve the red value for this example\n                     let val = red(img.get(xpos, ypos));\n                     // accumulate the  kernel sum\n\n                     // kernel is a 3x3 matrix\n\n                     // kx and ky have values -1, 0, 1\n\n                     // if we add 1 to kx and ky, we get 0, 1, 2\n\n                     // with that we can use it to iterate over kernel\n\n                     // and calculate the accumulated sum\n                     sum += kernel[ky + 1][kx + 1] * val;\n                 }\n             }\n             // set the pixel value of the edgeImg\n             edgeImg.set(x, y, color(sum, sum, sum));\n         }\n     }\n     // updatePixels() to write the changes on edgeImg\n     edgeImg.updatePixels();\n     // draw edgeImg at the right of the original image\n     image(edgeImg, img.width, 0);\n }"
            },
            {
                "name": "Brightness",
                "description": "This program adjusts the brightness of a part of the image by calculating the distance of each pixel to the mouse.\n\nThis example is ported from the Brightness example on the Processing website",
                "code": " // This program adjusts the brightness\n\n // of a part of the image by\n\n // calculating the distance of\n\n // each pixel to the mouse.\n let img;\n // preload() runs once, before setup()\n\n // loadImage() needs to occur here instead of setup()\n\n // preload() makes sure image is loaded before anything else occurs\n function preload() {\n     // load the original image\n     img = loadImage('assets/rover_wide.jpg');\n }\n // setup() runs after preload, once()\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     pixelDensity(1);\n     frameRate(30);\n }\n\n function draw() {\n     image(img, 0, 0);\n     // Only need to load the pixels[] array once, because we're only\n\n     // manipulating pixels[] inside draw(), not drawing shapes.\n     loadPixels();\n     // We must also call loadPixels() on the PImage since we are going to read its pixels.\n     img.loadPixels();\n     for (let x = 0; x < img.width; x++) {\n         for (let y = 0; y < img.height; y++) {\n             // Calculate the 1D location from a 2D grid\n             let loc = (x + y * img.width) * 4;\n             // Get the R,G,B values from image\n             let r, g, b;\n             r = img.pixels[loc];\n             // g = img.pixels[loc+1];\n\n             // b = img.pixels[loc+2];\n\n             // Calculate an amount to change brightness based on proximity to the mouse\n\n             // The closer the pixel is to the mouse, the lower the value of \"distance\"\n             let maxdist = 50;\n             //dist(0,0,width,height);\n             let d = dist(x, y, mouseX, mouseY);\n             let adjustbrightness = (255 * (maxdist - d)) / maxdist;\n             r += adjustbrightness;\n             // g += adjustbrightness;\n\n             // b += adjustbrightness;\n\n             // Constrain RGB to make sure they are within 0-255 color range\n             r = constrain(r, 0, 255);\n             // g = constrain(g, 0, 255);\n\n             // b = constrain(b, 0, 255);\n\n             // Make a new color and set pixel in the window\n             let pixloc = (y * width + x) * 4;\n             pixels[pixloc] = r;\n             pixels[pixloc + 1] = r;\n             pixels[pixloc + 2] = r;\n             pixels[pixloc + 3] = 255;\n             // Always have to set alpha\n         }\n     }\n     updatePixels();\n }"
            },
            {
                "name": "Convolution",
                "description": "Applies a convolution matrix to a portion of an image. Move mouse to apply filter to different parts of the image. This example is a port of Dan Shiffman's example for Processing. Original comments written by Dan unless otherwise specified.\n\nTo run this example locally, you will need an image file, and a running local server.",
                "code": " let img;\n let w = 80;\n // It's possible to convolve the image with many different\n\n // matrices to produce different effects. This is a high-pass\n\n // filter; it accentuates the edges.\n const matrix = [\n     [-1, -1, -1],\n     [-1, 9, -1],\n     [-1, -1, -1]\n ];\n\n function preload() {\n     img = loadImage('assets/moonwalk.jpg');\n }\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     img.loadPixels();\n     // pixelDensity(1) for not scaling pixel density to display density\n\n     // for more information, check the reference of pixelDensity()\n     pixelDensity(1);\n }\n\n function draw() {\n     // We're only going to process a portion of the image\n\n     // so let's set the whole image as the background first\n     background(img);\n     // Calculate the small rectangle we will process\n     const xstart = constrain(mouseX - w / 2, 0, img.width);\n     const ystart = constrain(mouseY - w / 2, 0, img.height);\n     const xend = constrain(mouseX + w / 2, 0, img.width);\n     const yend = constrain(mouseY + w / 2, 0, img.height);\n     const matrixsize = 3;\n     loadPixels();\n     // Begin our loop for every pixel in the smaller image\n     for (let x = xstart; x < xend; x++) {\n         for (let y = ystart; y < yend; y++) {\n             let c = convolution(x, y, matrix, matrixsize, img);\n             // retrieve the RGBA values from c and update pixels()\n             let loc = (x + y * img.width) * 4;\n             pixels[loc] = red(c);\n             pixels[loc + 1] = green(c);\n             pixels[loc + 2] = blue(c);\n             pixels[loc + 3] = alpha(c);\n         }\n     }\n     updatePixels();\n }\n\n function convolution(x, y, matrix, matrixsize, img) {\n     let rtotal = 0.0;\n     let gtotal = 0.0;\n     let btotal = 0.0;\n     const offset = Math.floor(matrixsize / 2);\n     for (let i = 0; i < matrixsize; i++) {\n         for (let j = 0; j < matrixsize; j++) {\n             // What pixel are we testing\n             const xloc = x + i - offset;\n             const yloc = y + j - offset;\n             let loc = (xloc + img.width * yloc) * 4;\n             // Make sure we haven't walked off our image, we could do better here\n             loc = constrain(loc, 0, img.pixels.length - 1);\n             // Calculate the convolution\n\n             // retrieve RGB values\n             rtotal += img.pixels[loc] * matrix[i][j];\n             gtotal += img.pixels[loc + 1] * matrix[i][j];\n             btotal += img.pixels[loc + 2] * matrix[i][j];\n         }\n     }\n     // Make sure RGB is within range\n     rtotal = constrain(rtotal, 0, 255);\n     gtotal = constrain(gtotal, 0, 255);\n     btotal = constrain(btotal, 0, 255);\n     // Return the resulting color\n     return color(rtotal, gtotal, btotal);\n }"
            },
            {
                "name": "Copy() method",
                "description": "An example of how to simulate coloring image with the copy() method.",
                "code": " let draft, ready;\n\n function preload() {\n     ready = loadImage('assets/parrot-color.png');\n     draft = loadImage('assets/parrot-bw.png');\n }\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     noCursor();\n     cursor('assets/brush.png', 20, -10);\n     image(ready, 0, 0);\n     image(draft, 0, 0);\n }\n\n function mouseDragged() {\n     copy(ready, mouseX, mouseY, 20, 20, mouseX, mouseY, 20, 20);\n }"
            }
        ]
    },
    {
        "groupName": "Color",
        "examples": [
            {
                "name": "Hue",
                "description": "Hue is the color reflected from or transmitted through an object and is typically referred to as the name of the color (red, blue, yellow, etc.) Move the cursor vertically over each bar to alter its hue.",
                "code": " const barWidth = 20;\n let lastBar = -1;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     colorMode(HSB, height, height, height);\n     noStroke();\n     background(0);\n }\n\n function draw() {\n     let whichBar = mouseX / barWidth;\n     if (whichBar !== lastBar) {\n         let barX = whichBar * barWidth;\n         fill(mouseY, height, height);\n         rect(barX, 0, barWidth, height);\n         lastBar = whichBar;\n     }\n }"
            },
            {
                "name": "Saturation",
                "description": "Saturation is the strength or purity of the color and represents the amount of gray in proportion to the hue. A \"saturated\" color is pure and an \"unsaturated\" color has a large percentage of gray. Move the cursor vertically over each bar to alter its saturation.",
                "code": " const barWidth = 20;\n let lastBar = -1;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     colorMode(HSB, width, height, 100);\n     noStroke();\n }\n\n function draw() {\n     let whichBar = mouseX / barWidth;\n     if (whichBar !== lastBar) {\n         let barX = whichBar * barWidth;\n         fill(barX, mouseY, 66);\n         rect(barX, 0, barWidth, height);\n         lastBar = whichBar;\n     }\n }"
            },
            {
                "name": "Brightness",
                "description": "By Dan Shiffman. This program adjusts the brightness of a part of the image by calculating the distance of each pixel to the mouse.\n\nTo run this example locally, you will need at least an image file and a running local server.",
                "code": " let img;\n\n function preload() {\n     img = loadImage('assets/moonwalk.jpg');\n }\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     pixelDensity(1);\n     img.loadPixels();\n     loadPixels();\n }\n\n function draw() {\n     for (let x = 0; x < img.width; x++) {\n         for (let y = 0; y < img.height; y++) {\n             // Calculate the 1D location from a 2D grid\n             let loc = (x + y * img.width) * 4;\n             // Get the R,G,B values from image\n             let r, g, b;\n             r = img.pixels[loc];\n             // Calculate an amount to change brightness based on proximity to the mouse\n             let maxdist = 50;\n             let d = dist(x, y, mouseX, mouseY);\n             let adjustbrightness = (255 * (maxdist - d)) / maxdist;\n             r += adjustbrightness;\n             // Constrain RGB to make sure they are within 0-255 color range\n             r = constrain(r, 0, 255);\n             // Make a new color and set pixel in the window\n\n             //color c = color(r, g, b);\n             let pixloc = (y * width + x) * 4;\n             pixels[pixloc] = r;\n             pixels[pixloc + 1] = r;\n             pixels[pixloc + 2] = r;\n             pixels[pixloc + 3] = 255;\n         }\n     }\n     updatePixels();\n }"
            },
            {
                "name": "Color Variables",
                "description": "(Homage to Albers.) This example creates variables for colors that may be referred to in the program by a name, rather than a number.",
                "code": " function setup() {\n     createCanvas(screenWidth, screenHeight);\n     noStroke();\n     background(51, 0, 0);\n     let inside = color(204, 102, 0);\n     let middle = color(204, 153, 0);\n     let outside = color(153, 51, 0);\n     // These statements are equivalent to the statements above.\n\n     // Programmers may use the format they prefer.\n\n     //let inside = color('#CC6600');\n\n     //let middle = color('#CC9900');\n\n     //let outside = color('#993300');\n     push();\n     translate(80, 80);\n     fill(outside);\n     rect(0, 0, 200, 200);\n     fill(middle);\n     rect(40, 60, 120, 120);\n     fill(inside);\n     rect(60, 90, 80, 80);\n     pop();\n     push();\n     translate(360, 80);\n     fill(inside);\n     rect(0, 0, 200, 200);\n     fill(outside);\n     rect(40, 60, 120, 120);\n     fill(middle);\n     rect(60, 90, 80, 80);\n     pop();\n }"
            },
            {
                "name": "Relativity",
                "description": "Each color is perceived in relation to other colors. The top and bottom bars each contain the same component colors, but a different display order causes individual colors to appear differently.",
                "code": " let a, b, c, d, e;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     noStroke();\n     a = color(165, 167, 20);\n     b = color(77, 86, 59);\n     c = color(42, 106, 105);\n     d = color(165, 89, 20);\n     e = color(146, 150, 127);\n     noLoop();\n     // Draw only one time\n }\n\n function draw() {\n     drawBand(a, b, c, d, e, 0, width / 128);\n     drawBand(c, a, d, b, e, height / 2, width / 128);\n }\n\n function drawBand(v, w, x, y, z, ypos, barWidth) {\n     let num = 5;\n     let colorOrder = [v, w, x, y, z];\n     for (let i = 0; i < width; i += barWidth * num) {\n         for (let j = 0; j < num; j++) {\n             fill(colorOrder[j]);\n             rect(i + j * barWidth, ypos, barWidth, height / 2);\n         }\n     }\n }"
            },
            {
                "name": "Linear Gradient",
                "description": "The lerpColor() function is useful for interpolating between two colors.",
                "code": " // Constants\n const Y_AXIS = 1;\n const X_AXIS = 2;\n let b1, b2, c1, c2;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     // Define colors\n     b1 = color(255);\n     b2 = color(0);\n     c1 = color(204, 102, 0);\n     c2 = color(0, 102, 153);\n     noLoop();\n }\n\n function draw() {\n     // Background\n     setGradient(0, 0, width / 2, height, b1, b2, X_AXIS);\n     setGradient(width / 2, 0, width / 2, height, b2, b1, X_AXIS);\n     // Foreground\n     setGradient(50, 90, 540, 80, c1, c2, Y_AXIS);\n     setGradient(50, 190, 540, 80, c2, c1, X_AXIS);\n }\n\n function setGradient(x, y, w, h, c1, c2, axis) {\n     noFill();\n     if (axis === Y_AXIS) {\n         // Top to bottom gradient\n         for (let i = y; i <= y + h; i++) {\n             let inter = map(i, y, y + h, 0, 1);\n             let c = lerpColor(c1, c2, inter);\n             stroke(c);\n             line(x, i, x + w, i);\n         }\n     } else if (axis === X_AXIS) {\n         // Left to right gradient\n         for (let i = x; i <= x + w; i++) {\n             let inter = map(i, x, x + w, 0, 1);\n             let c = lerpColor(c1, c2, inter);\n             stroke(c);\n             line(i, y, i, y + h);\n         }\n     }\n }"
            },
            {
                "name": "Radial Gradient",
                "description": "Draws a series of concentric circles to create a gradient from one color to another.",
                "code": " let dim;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     dim = width / 2;\n     background(0);\n     colorMode(HSB, 360, 100, 100);\n     noStroke();\n     ellipseMode(RADIUS);\n     frameRate(1);\n }\n\n function draw() {\n     background(0);\n     for (let x = 0; x <= width; x += dim) {\n         drawGradient(x, height / 2);\n     }\n }\n\n function drawGradient(x, y) {\n     let radius = dim / 2;\n     let h = random(0, 360);\n     for (let r = radius; r > 0; --r) {\n         fill(h, 90, 90);\n         ellipse(x, y, r, r);\n         h = (h + 1) % 360;\n     }\n }"
            },
            {
                "name": "Lerp Color",
                "description": "Loop random shapes, lerp color from red to blue.",
                "code": " function setup() {\n     createCanvas(screenWidth, screenHeight);\n     background(255);\n     noStroke();\n }\n\n function draw() {\n     background(255);\n     from = color(255, 0, 0, 0.2 * 255);\n     to = color(0, 0, 255, 0.2 * 255);\n     c1 = lerpColor(from, to, 0.33);\n     c2 = lerpColor(from, to, 0.66);\n     for (let i = 0; i < 15; i++) {\n         fill(from);\n         quad(random(-40, 220), random(height), random(-40, 220), random(height), random(-40, 220), random(height), random(-40, 220), random(height));\n         fill(c1);\n         quad(random(140, 380), random(height), random(140, 380), random(height), random(140, 380), random(height), random(140, 380), random(height));\n         fill(c2);\n         quad(random(320, 580), random(height), random(320, 580), random(height), random(320, 580), random(height), random(320, 580), random(height));\n         fill(to);\n         quad(random(500, 760), random(height), random(500, 760), random(height), random(500, 760), random(height), random(500, 760), random(height));\n     }\n     frameRate(5);\n }"
            }
        ]
    },
    {
        "groupName": "Math",
        "examples": [
            {
                "name": "Increment Decrement",
                "description": "Writing \"a++\" is equivalent to \"a = a + 1\". Writing \"a--\" is equivalent to \"a = a - 1\".",
                "code": " let a;\n let b;\n let direction;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     colorMode(RGB, width);\n     a = 0;\n     b = width;\n     direction = true;\n     frameRate(30);\n }\n\n function draw() {\n     a++;\n     if (a > width) {\n         a = 0;\n         direction = !direction;\n     }\n     if (direction === true) {\n         stroke(a);\n     } else {\n         stroke(width - a);\n     }\n     line(a, 0, a, height / 2);\n     b--;\n     if (b < 0) {\n         b = width;\n     }\n     if (direction == true) {\n         stroke(width - b);\n     } else {\n         stroke(b);\n     }\n     line(b, height / 2 + 1, b, height);\n }"
            },
            {
                "name": "Operator Precedence",
                "description": "If you don't explicitly state the order in which an expression is evaluated, they are evaluated based on the operator precedence. For example, in the statement \"4+2*8\", the 2 will first be multiplied by 8 and then the result will be added to 4. This is because the \"*\" has a higher precedence than the \"+\". To avoid ambiguity in reading the program, it is recommended that is statement is written as \"4+(2*8)\". The order of evaluation can be controlled through placement of parenthesis in the code. A table of operator precedence follows below.",
                "code": " // The highest precedence is at the top of the list and\n\n // the lowest is at the bottom.\n\n // Multiplicative: * / %\n\n // Additive: + -\n\n // Relational: < > <= >=\n\n // Equality: == !=\n\n // Logical AND: &&\n\n // Logical OR: ||\n\n // Assignment: = += -= *= /= %=\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     background(51);\n     noFill();\n     stroke(51);\n     stroke(204);\n     for (let i = 0; i < width - 20; i += 4) {\n         // The 30 is added to 70 and then evaluated\n\n         // if it is greater than the current value of \"i\"\n\n         // For clarity, write as \"if (i > (30 + 70)) {\"\n         if (i > 30 + 70) {\n             line(i, 0, i, 50);\n         }\n     }\n     stroke(255);\n     // The 2 is multiplied by the 8 and the result is added to the 4\n\n     // For clarity, write as \"rect(5 + (2 * 8), 0, 90, 20);\"\n     rect(4 + 2 * 8, 52, 290, 48);\n     rect((4 + 2) * 8, 100, 290, 49);\n     stroke(153);\n     for (let i = 0; i < width; i += 2) {\n         // The relational statements are evaluated\n\n         // first, and then the logical AND statements and\n\n         // finally the logical OR. For clarity, write as:\n\n         // \"if(((i > 20) && (i < 50)) || ((i > 100) && (i < width-20))) {\"\n         if ((i > 20 && i < 50) || (i > 100 && i < width - 20)) {\n             line(i, 151, i, height - 1);\n         }\n     }\n }"
            },
            {
                "name": "Distance 1D",
                "description": "Move the mouse left and right to control the speed and direction of the moving shapes.",
                "code": " let xpos1;\n let xpos2;\n let xpos3;\n let xpos4;\n let thin = 8;\n let thick = 36;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     noStroke();\n     xpos1 = width / 2;\n     xpos2 = width / 2;\n     xpos3 = width / 2;\n     xpos4 = width / 2;\n }\n\n function draw() {\n     background(0);\n     let mx = mouseX * 0.4 - width / 5.0;\n     fill(102);\n     rect(xpos2, 0, thick, height / 2);\n     fill(204);\n     rect(xpos1, 0, thin, height / 2);\n     fill(102);\n     rect(xpos4, height / 2, thick, height / 2);\n     fill(204);\n     rect(xpos3, height / 2, thin, height / 2);\n     xpos1 += mx / 16;\n     xpos2 += mx / 64;\n     xpos3 -= mx / 16;\n     xpos4 -= mx / 64;\n     if (xpos1 < -thin) {\n         xpos1 = width;\n     }\n     if (xpos1 > width) {\n         xpos1 = -thin;\n     }\n     if (xpos2 < -thick) {\n         xpos2 = width;\n     }\n     if (xpos2 > width) {\n         xpos2 = -thick;\n     }\n     if (xpos3 < -thin) {\n         xpos3 = width;\n     }\n     if (xpos3 > width) {\n         xpos3 = -thin;\n     }\n     if (xpos4 < -thick) {\n         xpos4 = width;\n     }\n     if (xpos4 > width) {\n         xpos4 = -thick;\n     }\n }"
            },
            {
                "name": "Distance 2D",
                "description": "Move the mouse across the image to obscure and reveal the matrix. Measures the distance from the mouse to each circle and sets the size proportionally.",
                "code": " let max_distance;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     noStroke();\n     max_distance = dist(0, 0, width, height);\n }\n\n function draw() {\n     background(0);\n     for (let i = 0; i <= width; i += 20) {\n         for (let j = 0; j <= height; j += 20) {\n             let size = dist(mouseX, mouseY, i, j);\n             size = (size / max_distance) * 66;\n             ellipse(i, j, size, size);\n         }\n     }\n }"
            },
            {
                "name": "Sine",
                "description": "Smoothly scaling size with the sin() function.",
                "code": " let diameter;\n let angle = 0;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     diameter = height - 10;\n     noStroke();\n     fill(255, 204, 0);\n }\n\n function draw() {\n     background(0);\n     let d1 = 10 + (sin(angle) * diameter) / 2 + diameter / 2;\n     let d2 = 10 + (sin(angle + PI / 2) * diameter) / 2 + diameter / 2;\n     let d3 = 10 + (sin(angle + PI) * diameter) / 2 + diameter / 2;\n     ellipse(0, height / 2, d1, d1);\n     ellipse(width / 2, height / 2, d2, d2);\n     ellipse(width, height / 2, d3, d3);\n     angle += 0.02;\n }"
            },
            {
                "name": "Sine Cosine",
                "description": "Linear movement with sin() and cos(). Numbers between 0 and 2π (2π which angles roughly 6.28) are put into these functions and numbers between -1 and 1 are returned. These values are then scaled to produce larger movements.",
                "code": " let angle1 = 0;\n let angle2 = 0;\n let scalar = 70;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     noStroke();\n     rectMode(CENTER);\n }\n\n function draw() {\n     background(0);\n     let ang1 = radians(angle1);\n     let ang2 = radians(angle2);\n     let x1 = width / 2 + scalar * cos(ang1);\n     let x2 = width / 2 + scalar * cos(ang2);\n     let y1 = height / 2 + scalar * sin(ang1);\n     let y2 = height / 2 + scalar * sin(ang2);\n     fill(255);\n     rect(width * 0.5, height * 0.5, 140, 140);\n     fill(0, 102, 153);\n     ellipse(x1, height * 0.5 - 120, scalar, scalar);\n     ellipse(x2, height * 0.5 + 120, scalar, scalar);\n     fill(255, 204, 0);\n     ellipse(width * 0.5 - 120, y1, scalar, scalar);\n     ellipse(width * 0.5 + 120, y2, scalar, scalar);\n     angle1 += 2;\n     angle2 += 3;\n }"
            },
            {
                "name": "Sine Wave",
                "description": "Render a simple sine wave. Original by Daniel Shiffman.",
                "code": " let xspacing = 16;\n // Distance between each horizontal location\n let w;\n // Width of entire wave\n let theta = 0.0;\n // Start angle at 0\n let amplitude = 75.0;\n // Height of wave\n let period = 500.0;\n // How many pixels before the wave repeats\n let dx;\n // Value for incrementing x\n let yvalues;\n // Using an array to store height values for the wave\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     w = width + 16;\n     dx = (TWO_PI / period) * xspacing;\n     yvalues = new Array(floor(w / xspacing));\n }\n\n function draw() {\n     background(0);\n     calcWave();\n     renderWave();\n }\n\n function calcWave() {\n     // Increment theta (try different values for\n\n     // 'angular velocity' here)\n     theta += 0.02;\n     // For every x value, calculate a y value with sine function\n     let x = theta;\n     for (let i = 0; i < yvalues.length; i++) {\n         yvalues[i] = sin(x) * amplitude;\n         x += dx;\n     }\n }\n\n function renderWave() {\n     noStroke();\n     fill(255);\n     // A simple way to draw the wave with an ellipse at each location\n     for (let x = 0; x < yvalues.length; x++) {\n         ellipse(x * xspacing, height / 2 + yvalues[x], 16, 16);\n     }\n }"
            },
            {
                "name": "Additive Wave",
                "description": "Create a more complex wave by adding two waves together. Original by Daniel Shiffman",
                "code": " let xspacing = 8;\n // Distance between each horizontal location\n let w;\n // Width of entire wave\n let maxwaves = 4;\n // total # of waves to add together\n let theta = 0.0;\n let amplitude = new Array(maxwaves);\n // Height of wave\n\n // Value for incrementing X, to be calculated\n\n // as a function of period and xspacing\n let dx = new Array(maxwaves);\n // Using an array to store height values\n\n // for the wave (not entirely necessary)\n let yvalues;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     frameRate(30);\n     colorMode(RGB, 255, 255, 255, 100);\n     w = width + 16;\n     for (let i = 0; i < maxwaves; i++) {\n         amplitude[i] = random(10, 30);\n         let period = random(100, 300);\n         // Num pixels before wave repeats\n         dx[i] = (TWO_PI / period) * xspacing;\n     }\n     yvalues = new Array(floor(w / xspacing));\n }\n\n function draw() {\n     background(0);\n     calcWave();\n     renderWave();\n }\n\n function calcWave() {\n     // Increment theta (try different values\n\n     // for 'angular velocity' here\n     theta += 0.02;\n     // Set all height values to zero\n     for (let i = 0; i < yvalues.length; i++) {\n         yvalues[i] = 0;\n     }\n     // Accumulate wave height values\n     for (let j = 0; j < maxwaves; j++) {\n         let x = theta;\n         for (let i = 0; i < yvalues.length; i++) {\n             // Every other wave is cosine instead of sine\n             if (j % 2 == 0) yvalues[i] += sin(x) * amplitude[j];\n             else yvalues[i] += cos(x) * amplitude[j];\n             x += dx[j];\n         }\n     }\n }\n\n function renderWave() {\n     // A simple way to draw the wave with an ellipse at each location\n     noStroke();\n     fill(255, 50);\n     ellipseMode(CENTER);\n     for (let x = 0; x < yvalues.length; x++) {\n         ellipse(x * xspacing, width / 2 + yvalues[x], 16, 16);\n     }\n }"
            },
            {
                "name": "PolarToCartesian",
                "description": "Convert a polar coordinate (r,θ) to cartesian (x,y): x = r cos(θ), y = r sin(θ) Original by Daniel Shiffman.",
                "code": " let r;\n // Angle and angular velocity, accleration\n let theta;\n let theta_vel;\n let theta_acc;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     // Initialize all values\n     r = height * 0.45;\n     theta = 0;\n     theta_vel = 0;\n     theta_acc = 0.0001;\n }\n\n function draw() {\n     background(0);\n     // Translate the origin point to the center of the screen\n     translate(width / 2, height / 2);\n     // Convert polar to cartesian\n     let x = r * cos(theta);\n     let y = r * sin(theta);\n     // Draw the ellipse at the cartesian coordinate\n     ellipseMode(CENTER);\n     noStroke();\n     fill(200);\n     ellipse(x, y, 32, 32);\n     // Apply acceleration and velocity to angle\n\n     // (r remains static in this example)\n     theta_vel += theta_acc;\n     theta += theta_vel;\n }"
            },
            {
                "name": "Arctangent",
                "description": "Move the mouse to change the direction of the eyes.\nThe atan2() function computes the angle from each eye to the cursor.",
                "code": " let e1, e2, e3;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     noStroke();\n     e1 = new Eye(250, 16, 120);\n     e2 = new Eye(164, 185, 80);\n     e3 = new Eye(420, 230, 220);\n }\n\n function draw() {\n     background(102);\n     e1.update(mouseX, mouseY);\n     e2.update(mouseX, mouseY);\n     e3.update(mouseX, mouseY);\n     e1.display();\n     e2.display();\n     e3.display();\n }\n\n function Eye(tx, ty, ts) {\n     this.x = tx;\n     this.y = ty;\n     this.size = ts;\n     this.angle = 0;\n     this.update = function(mx, my) {\n         this.angle = atan2(my - this.y, mx - this.x);\n     };\n     this.display = function() {\n         push();\n         translate(this.x, this.y);\n         fill(255);\n         ellipse(0, 0, this.size, this.size);\n         rotate(this.angle);\n         fill(153, 204, 0);\n         ellipse(this.size / 4, 0, this.size / 2, this.size / 2);\n         pop();\n     };\n }"
            },
            {
                "name": "Linear Interpolation",
                "description": "Move the mouse across the screen and the symbol will follow. Between drawing each frame of the animation, the ellipse moves part of the distance (0.05) from its current position toward the cursor using the lerp() function. This is the same as the Easing under input only with lerp() instead..",
                "code": " let x = 0;\n let y = 0;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     noStroke();\n }\n\n function draw() {\n     background(51);\n     // lerp() calculates a number between two numbers at a specific increment.\n\n     // The amt parameter is the amount to interpolate between the two values\n\n     // where 0.0 equal to the first point, 0.1 is very near the first point, 0.5\n\n     // is half-way in between, etc.\n\n     // Here we are moving 5% of the way to the mouse location each frame\n     x = lerp(x, mouseX, 0.05);\n     y = lerp(y, mouseY, 0.05);\n     fill(255);\n     stroke(255);\n     ellipse(x, y, 66, 66);\n }"
            },
            {
                "name": "Double Random",
                "description": "Using two random() calls and the point() function to create an irregular sawtooth line. Original by by Ira Greenberg.",
                "code": " let totalPts = 300;\n let steps = totalPts + 1;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     stroke(255);\n     frameRate(1);\n }\n\n function draw() {\n     background(0);\n     let rand = 0;\n     for (let i = 1; i < steps; i++) {\n         point((width / steps) * i, height / 2 + random(-rand, rand));\n         rand += random(-5, 5);\n     }\n }"
            },
            {
                "name": "Random",
                "description": "Random numbers create the basis of this image. Each time the program is loaded the result is different.",
                "code": " function setup() {\n     createCanvas(screenWidth, screenHeight);\n     background(0);\n     strokeWeight(20);\n     frameRate(2);\n }\n\n function draw() {\n     for (let i = 0; i < width; i++) {\n         let r = random(255);\n         stroke(r);\n         line(i, 0, i, height);\n     }\n }"
            },
            {
                "name": "Noise1D",
                "description": "Using 1D Perlin Noise to assign location.",
                "code": " let xoff = 0.0;\n let xincrement = 0.01;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     background(0);\n     noStroke();\n }\n\n function draw() {\n     // Create an alpha blended background\n     fill(0, 10);\n     rect(0, 0, width, height);\n     //let n = random(0,width);  // Try this line instead of noise\n\n     // Get a noise value based on xoff and scale\n\n     // it according to the window's width\n     let n = noise(xoff) * width;\n     // With each cycle, increment xoff\n     xoff += xincrement;\n     // Draw the ellipse at the value produced by perlin noise\n     fill(200);\n     ellipse(n, height / 2, 64, 64);\n }"
            },
            {
                "name": "Noise Wave",
                "description": "Using Perlin Noise to generate a wave-like pattern. Original by Daniel Shiffman.",
                "code": " let yoff = 0.0;\n // 2nd dimension of perlin noise\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n }\n\n function draw() {\n     background(51);\n     fill(255);\n     // We are going to draw a polygon out of the wave points\n     beginShape();\n     let xoff = 0;\n     // Option #1: 2D Noise\n\n     // let xoff = yoff; // Option #2: 1D Noise\n\n     // Iterate over horizontal pixels\n     for (let x = 0; x <= width; x += 10) {\n         // Calculate a y value according to noise, map to\n\n         // Option #1: 2D Noise\n         let y = map(noise(xoff, yoff), 0, 1, 200, 300);\n         // Option #2: 1D Noise\n\n         // let y = map(noise(xoff), 0, 1, 200,300);\n\n         // Set the vertex\n         vertex(x, y);\n         // Increment x dimension for noise\n         xoff += 0.05;\n     }\n     // increment y dimension for noise\n     yoff += 0.01;\n     vertex(width, height);\n     vertex(0, height);\n     endShape(CLOSE);\n }"
            },
            {
                "name": "Noise2D",
                "description": "Create a 2D noise with different parameters. *",
                "code": " let noiseVal;\n let noiseScale = 0.02;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n }\n\n function draw() {\n     background(0);\n     // Draw the left half of image\n     for (let y = 0; y < height - 30; y++) {\n         for (let x = 0; x < width / 2; x++) {\n             // noiseDetail of the pixels octave count and falloff value\n             noiseDetail(2, 0.2);\n             noiseVal = noise((mouseX + x) * noiseScale, (mouseY + y) * noiseScale);\n             stroke(noiseVal * 255);\n             point(x, y);\n         }\n     }\n     // Draw the right half of image\n     for (let y = 0; y < height - 30; y++) {\n         for (let x = width / 2; x < width; x++) {\n             // noiseDetail of the pixels octave count and falloff value\n             noiseDetail(5, 0.5);\n             noiseVal = noise((mouseX + x) * noiseScale, (mouseY + y) * noiseScale);\n             stroke(noiseVal * 255);\n             point(x, y);\n         }\n     }\n     //Show the details of two partitions\n     textSize(18);\n     fill(255, 255, 255);\n     text('Noise2D with 2 octaves and 0.2 falloff', 10, 350);\n     text('Noise2D with 1 octaves and 0.7 falloff', 330, 350);\n }"
            },
            {
                "name": "Noise3D",
                "description": "Using 3D noise to create simple animated texture.",
                "code": " let noiseVal;\n //Increment x by 0.01\n let x_increment = 0.01;\n //Increment z by 0.02 every draw() cycle\n let z_increment = 0.02;\n //Offset values\n let z_off, y_off, x_off;\n\n function setup() {\n     //Create the Canvas\n     createCanvas(screenWidth, screenHeight);\n     //Define frame rate\n     frameRate(20);\n     //Initial value of z_off\n     z_off = 0;\n }\n\n function draw() {\n     x_off = 0;\n     y_off = 0;\n     //Make the background black\n     background(0);\n     //Adjust the noice detail\n     noiseDetail(8, 0.65);\n     //For each x,y calculate noice value\n     for (let y = 0; y < height; y++) {\n         x_off += x_increment;\n         y_off = 0;\n         for (let x = 0; x < width; x++) {\n             //Calculate and Draw each pixel\n             noiseVal = noise(x_off, y_off, z_off);\n             stroke(noiseVal * 255);\n             y_off += x_increment;\n             point(x, y);\n         }\n     }\n     z_off += z_increment;\n }"
            },
            {
                "name": "Random Chords",
                "description": "Accumulates random chords of a circle. Each chord in translucent so they accumulate to give the illusion of a shaded sphere. Contributed by Aatish Bhatia, inspired by Anders Hoff",
                "code": " function setup() {\n     createCanvas(screenWidth, screenHeight);\n     background(255, 255, 255);\n     // translucent stroke using alpha value\n     stroke(0, 0, 0, 15);\n }\n\n function draw() {\n     // draw two random chords each frame\n     randomChord();\n     randomChord();\n }\n\n function randomChord() {\n     // find a random point on a circle\n     let angle1 = random(0, 2 * PI);\n     let xpos1 = 200 + 200 * cos(angle1);\n     let ypos1 = 200 + 200 * sin(angle1);\n     // find another random point on the circle\n     let angle2 = random(0, 2 * PI);\n     let xpos2 = 200 + 200 * cos(angle2);\n     let ypos2 = 200 + 200 * sin(angle2);\n     // draw a line between them\n     line(xpos1, ypos1, xpos2, ypos2);\n }"
            },
            {
                "name": "Random Gaussian",
                "description": "This sketch draws ellipses with x and y locations tied to a gaussian distribution of random numbers.\n\nThis example is ported from the Random Gaussian example on the Processing website",
                "code": " function setup() {\n     createCanvas(screenWidth, screenHeight);\n     background(0);\n }\n\n function draw() {\n     // Get a gaussian random number w/ mean of 0 and standard deviation of 1.0\n     let val = randomGaussian();\n     let sd = 60;\n     // Define a standard deviation\n     let mean = width / 2;\n     // Define a mean value (middle of the screen along the x-axis)\n     let x = (val * sd) + mean;\n     // Scale the gaussian random number by standard deviation and mean\n     noStroke();\n     fill(255, 10);\n     ellipse(x, height / 2, 32, 32);\n     // Draw an ellipse at our \"normal\" random location\n }"
            },
            {
                "name": "Map",
                "description": "Use the map() function to take any number and scale it to a new number that is more useful for the project that you are working on. For example, use the numbers from the mouse position to control the size or color of a shape. In this example, the mouse’s x-coordinate (numbers between 0 and 360) are scaled to new numbers to define the color and size of a circle.",
                "code": " function setup() {\n     createCanvas(screenWidth, screenHeight);\n     noStroke();\n }\n\n function draw() {\n     background(0);\n     // Scale the mouseX value from 0 to 720 to a range between 0 and 175\n     let c = map(mouseX, 0, width, 0, 175);\n     // Scale the mouseX value from 0 to 720 to a range between 40 and 300\n     let d = map(mouseX, 0, width, 40, 300);\n     fill(255, c, 0);\n     ellipse(width / 2, height / 2, d, d);\n }"
            },
            {
                "name": "Graphing 2D Equations",
                "description": "Graphics the following equation: sin(n cos(r) + 5θ) where n is a function of horizontal mouse location. Original by Daniel Shiffman",
                "code": " function setup() {\n     createCanvas(screenWidth, screenHeight);\n     pixelDensity(1);\n }\n\n function draw() {\n     loadPixels();\n     let n = (mouseX * 10.0) / width;\n     const w = 16.0;\n     // 2D space width\n     const h = 16.0;\n     // 2D space height\n     const dx = w / width;\n     // Increment x this amount per pixel\n     const dy = h / height;\n     // Increment y this amount per pixel\n     let x = -w / 2;\n     // Start x at -1 * width / 2\n     let y;\n     let r;\n     let theta;\n     let val;\n     let bw;\n     //variable to store grayscale\n     let i;\n     let j;\n     let cols = width;\n     let rows = height;\n     for (i = 0; i < cols; i += 1) {\n         y = -h / 2;\n         for (j = 0; j < rows; j += 1) {\n             r = sqrt(x * x + y * y);\n             // Convert cartesian to polar\n             theta = atan2(y, x);\n             // Convert cartesian to polar\n\n             // Compute 2D polar coordinate function\n             val = sin(n * cos(r) + 5 * theta);\n             // Results in a value between -1 and 1\n\n             //var val = cos(r);                            // Another simple function\n\n             //var val = sin(theta);                        // Another simple function\n             bw = color(((val + 1) * 255) / 2);\n             index = 4 * (i + j * width);\n             pixels[index] = red(bw);\n             pixels[index + 1] = green(bw);\n             pixels[index + 2] = blue(bw);\n             pixels[index + 3] = alpha(bw);\n             y += dy;\n         }\n         x += dx;\n     }\n     updatePixels();\n }"
            },
            {
                "name": "Parametric Equations",
                "description": "A parametric equation is where x and y coordinates are both written in terms of another letter. This is called a parameter and is usually given in the letter t or θ. The inspiration was taken from the YouTube channel of Alexander Miller.",
                "code": " function setup() {\n     createCanvas(screenWidth, screenHeight);\n }\n // the parameter at which x and y depends is usually taken as either t or symbol of theta\n let t = 0;\n\n function draw() {\n     background('#fff');\n     translate(width / 2, height / 2);\n     stroke('#0f0f0f');\n     strokeWeight(1.5);\n     //loop for adding 100 lines\n     for (let i = 0; i < 100; i++) {\n         line(x1(t + i), y1(t + i), x2(t + i) + 20, y2(t + i) + 20);\n     }\n     t += 0.15;\n }\n // function to change initial x co-ordinate of the line\n function x1(t) {\n     return sin(t / 10) * 125 + sin(t / 20) * 125 + sin(t / 30) * 125;\n }\n // function to change initial y co-ordinate of the line\n function y1(t) {\n     return cos(t / 10) * 125 + cos(t / 20) * 125 + cos(t / 30) * 125;\n }\n // function to change final x co-ordinate of the line\n function x2(t) {\n     return sin(t / 15) * 125 + sin(t / 25) * 125 + sin(t / 35) * 125;\n }\n // function to change final y co-ordinate of the line\n function y2(t) {\n     return cos(t / 15) * 125 + cos(t / 25) * 125 + cos(t / 35) * 125;\n }"
            }
        ]
    },
    {
        "groupName": "Simulate",
        "examples": [
            {
                "name": "Forces",
                "description": "Demonstration of multiple force acting on bodies (natureofcode.com)",
                "code": " // Demonstration of multiple force acting on\n\n // bodies (Mover class)\n\n // Bodies experience gravity continuously\n\n // Bodies experience fluid resistance when in \"water\"\n\n // Nine moving bodies\n let movers = [];\n // Liquid\n let liquid;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     reset();\n     // Create liquid object\n     liquid = new Liquid(0, height / 2, width, height / 2, 0.1);\n }\n\n function draw() {\n     background(127);\n     // Draw water\n     liquid.display();\n     for (let i = 0; i < movers.length; i++) {\n         // Is the Mover in the liquid?\n         if (liquid.contains(movers[i])) {\n             // Calculate drag force\n             let dragForce = liquid.calculateDrag(movers[i]);\n             // Apply drag force to Mover\n             movers[i].applyForce(dragForce);\n         }\n         // Gravity is scaled by mass here!\n         let gravity = createVector(0, 0.1 * movers[i].mass);\n         // Apply gravity\n         movers[i].applyForce(gravity);\n         // Update and display\n         movers[i].update();\n         movers[i].display();\n         movers[i].checkEdges();\n     }\n }\n\n function mousePressed() {\n     reset();\n }\n // Restart all the Mover objects randomly\n function reset() {\n     for (let i = 0; i < 9; i++) {\n         movers[i] = new Mover(random(0.5, 3), 40 + i * 70, 0);\n     }\n }\n let Liquid = function(x, y, w, h, c) {\n     this.x = x;\n     this.y = y;\n     this.w = w;\n     this.h = h;\n     this.c = c;\n };\n // Is the Mover in the Liquid?\n Liquid.prototype.contains = function(m) {\n     let l = m.position;\n     return (l.x > this.x && l.x < this.x + this.w && l.y > this.y && l.y < this.y + this.h);\n };\n // Calculate drag force\n Liquid.prototype.calculateDrag = function(m) {\n     // Magnitude is coefficient * speed squared\n     let speed = m.velocity.mag();\n     let dragMagnitude = this.c * speed * speed;\n     // Direction is inverse of velocity\n     let dragForce = m.velocity.copy();\n     dragForce.mult(-1);\n     // Scale according to magnitude\n\n     // dragForce.setMag(dragMagnitude);\n     dragForce.normalize();\n     dragForce.mult(dragMagnitude);\n     return dragForce;\n };\n Liquid.prototype.display = function() {\n     noStroke();\n     fill(50);\n     rect(this.x, this.y, this.w, this.h);\n };\n\n function Mover(m, x, y) {\n     this.mass = m;\n     this.position = createVector(x, y);\n     this.velocity = createVector(0, 0);\n     this.acceleration = createVector(0, 0);\n }\n // Newton's 2nd law: F = M * A\n\n // or A = F / M\n Mover.prototype.applyForce = function(force) {\n     let f = p5.Vector.div(force, this.mass);\n     this.acceleration.add(f);\n };\n Mover.prototype.update = function() {\n     // Velocity changes according to acceleration\n     this.velocity.add(this.acceleration);\n     // position changes by velocity\n     this.position.add(this.velocity);\n     // We must clear acceleration each frame\n     this.acceleration.mult(0);\n };\n Mover.prototype.display = function() {\n     stroke(0);\n     strokeWeight(2);\n     fill(255, 127);\n     ellipse(this.position.x, this.position.y, this.mass * 16, this.mass * 16);\n };\n // Bounce off bottom of window\n Mover.prototype.checkEdges = function() {\n     if (this.position.y > height - this.mass * 8) {\n         // A little dampening when hitting the bottom\n         this.velocity.y *= -0.9;\n         this.position.y = height - this.mass * 8;\n     }\n };"
            },
            {
                "name": "Particle System",
                "description": "This is a basic Particle System (natureofcode.com)",
                "code": " let system;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     system = new ParticleSystem(createVector(width / 2, 50));\n }\n\n function draw() {\n     background(51);\n     system.addParticle();\n     system.run();\n }\n // A simple Particle class\n let Particle = function(position) {\n     this.acceleration = createVector(0, 0.05);\n     this.velocity = createVector(random(-1, 1), random(-1, 0));\n     this.position = position.copy();\n     this.lifespan = 255;\n };\n Particle.prototype.run = function() {\n     this.update();\n     this.display();\n };\n // Method to update position\n Particle.prototype.update = function() {\n     this.velocity.add(this.acceleration);\n     this.position.add(this.velocity);\n     this.lifespan -= 2;\n };\n // Method to display\n Particle.prototype.display = function() {\n     stroke(200, this.lifespan);\n     strokeWeight(2);\n     fill(127, this.lifespan);\n     ellipse(this.position.x, this.position.y, 12, 12);\n };\n // Is the particle still useful?\n Particle.prototype.isDead = function() {\n     return this.lifespan < 0;\n };\n let ParticleSystem = function(position) {\n     this.origin = position.copy();\n     this.particles = [];\n };\n ParticleSystem.prototype.addParticle = function() {\n     this.particles.push(new Particle(this.origin));\n };\n ParticleSystem.prototype.run = function() {\n     for (let i = this.particles.length - 1; i >= 0; i--) {\n         let p = this.particles[i];\n         p.run();\n         if (p.isDead()) {\n             this.particles.splice(i, 1);\n         }\n     }\n };"
            },
            {
                "name": "Flocking",
                "description": "Demonstration of Craig Reynolds' \"Flocking\" behavior. See: http://www.red3d.com/cwr/ Rules: Cohesion, Separation, Alignment (from natureofcode.com). Drag mouse to add boids into the system.",
                "code": " let flock;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     createP(\"Drag the mouse to generate new boids.\");\n     flock = new Flock();\n     // Add an initial set of boids into the system\n     for (let i = 0; i < 100; i++) {\n         let b = new Boid(width / 2, height / 2);\n         flock.addBoid(b);\n     }\n }\n\n function draw() {\n     background(51);\n     flock.run();\n }\n // Add a new boid into the System\n function mouseDragged() {\n     flock.addBoid(new Boid(mouseX, mouseY));\n }\n // The Nature of Code\n\n // Daniel Shiffman\n\n // http://natureofcode.com\n\n // Flock object\n\n // Does very little, simply manages the array of all the boids\n function Flock() {\n     // An array for all the boids\n     this.boids = [];\n     // Initialize the array\n }\n Flock.prototype.run = function() {\n     for (let i = 0; i < this.boids.length; i++) {\n         this.boids[i].run(this.boids);\n         // Passing the entire list of boids to each boid individually\n     }\n }\n Flock.prototype.addBoid = function(b) {\n     this.boids.push(b);\n }\n // The Nature of Code\n\n // Daniel Shiffman\n\n // http://natureofcode.com\n\n // Boid class\n\n // Methods for Separation, Cohesion, Alignment added\n function Boid(x, y) {\n     this.acceleration = createVector(0, 0);\n     this.velocity = createVector(random(-1, 1), random(-1, 1));\n     this.position = createVector(x, y);\n     this.r = 3.0;\n     this.maxspeed = 3;\n     // Maximum speed\n     this.maxforce = 0.05;\n     // Maximum steering force\n }\n Boid.prototype.run = function(boids) {\n     this.flock(boids);\n     this.update();\n     this.borders();\n     this.render();\n }\n Boid.prototype.applyForce = function(force) {\n     // We could add mass here if we want A = F / M\n     this.acceleration.add(force);\n }\n // We accumulate a new acceleration each time based on three rules\n Boid.prototype.flock = function(boids) {\n     let sep = this.separate(boids);\n     // Separation\n     let ali = this.align(boids);\n     // Alignment\n     let coh = this.cohesion(boids);\n     // Cohesion\n\n     // Arbitrarily weight these forces\n     sep.mult(1.5);\n     ali.mult(1.0);\n     coh.mult(1.0);\n     // Add the force vectors to acceleration\n     this.applyForce(sep);\n     this.applyForce(ali);\n     this.applyForce(coh);\n }\n // Method to update location\n Boid.prototype.update = function() {\n     // Update velocity\n     this.velocity.add(this.acceleration);\n     // Limit speed\n     this.velocity.limit(this.maxspeed);\n     this.position.add(this.velocity);\n     // Reset accelertion to 0 each cycle\n     this.acceleration.mult(0);\n }\n // A method that calculates and applies a steering force towards a target\n\n // STEER = DESIRED MINUS VELOCITY\n Boid.prototype.seek = function(target) {\n     let desired = p5.Vector.sub(target, this.position);\n     // A vector pointing from the location to the target\n\n     // Normalize desired and scale to maximum speed\n     desired.normalize();\n     desired.mult(this.maxspeed);\n     // Steering = Desired minus Velocity\n     let steer = p5.Vector.sub(desired, this.velocity);\n     steer.limit(this.maxforce);\n     // Limit to maximum steering force\n     return steer;\n }\n Boid.prototype.render = function() {\n     // Draw a triangle rotated in the direction of velocity\n     let theta = this.velocity.heading() + radians(90);\n     fill(127);\n     stroke(200);\n     push();\n     translate(this.position.x, this.position.y);\n     rotate(theta);\n     beginShape();\n     vertex(0, -this.r * 2);\n     vertex(-this.r, this.r * 2);\n     vertex(this.r, this.r * 2);\n     endShape(CLOSE);\n     pop();\n }\n // Wraparound\n Boid.prototype.borders = function() {\n     if (this.position.x < -this.r) this.position.x = width + this.r;\n     if (this.position.y < -this.r) this.position.y = height + this.r;\n     if (this.position.x > width + this.r) this.position.x = -this.r;\n     if (this.position.y > height + this.r) this.position.y = -this.r;\n }\n // Separation\n\n // Method checks for nearby boids and steers away\n Boid.prototype.separate = function(boids) {\n     let desiredseparation = 25.0;\n     let steer = createVector(0, 0);\n     let count = 0;\n     // For every boid in the system, check if it's too close\n     for (let i = 0; i < boids.length; i++) {\n         let d = p5.Vector.dist(this.position, boids[i].position);\n         // If the distance is greater than 0 and less than an arbitrary amount (0 when you are yourself)\n         if ((d > 0) && (d < desiredseparation)) {\n             // Calculate vector pointing away from neighbor\n             let diff = p5.Vector.sub(this.position, boids[i].position);\n             diff.normalize();\n             diff.div(d);\n             // Weight by distance\n             steer.add(diff);\n             count++;\n             // Keep track of how many\n         }\n     }\n     // Average -- divide by how many\n     if (count > 0) {\n         steer.div(count);\n     }\n     // As long as the vector is greater than 0\n     if (steer.mag() > 0) {\n         // Implement Reynolds: Steering = Desired - Velocity\n         steer.normalize();\n         steer.mult(this.maxspeed);\n         steer.sub(this.velocity);\n         steer.limit(this.maxforce);\n     }\n     return steer;\n }\n // Alignment\n\n // For every nearby boid in the system, calculate the average velocity\n Boid.prototype.align = function(boids) {\n     let neighbordist = 50;\n     let sum = createVector(0, 0);\n     let count = 0;\n     for (let i = 0; i < boids.length; i++) {\n         let d = p5.Vector.dist(this.position, boids[i].position);\n         if ((d > 0) && (d < neighbordist)) {\n             sum.add(boids[i].velocity);\n             count++;\n         }\n     }\n     if (count > 0) {\n         sum.div(count);\n         sum.normalize();\n         sum.mult(this.maxspeed);\n         let steer = p5.Vector.sub(sum, this.velocity);\n         steer.limit(this.maxforce);\n         return steer;\n     } else {\n         return createVector(0, 0);\n     }\n }\n // Cohesion\n\n // For the average location (i.e. center) of all nearby boids, calculate steering vector towards that location\n Boid.prototype.cohesion = function(boids) {\n     let neighbordist = 50;\n     let sum = createVector(0, 0);\n     // Start with empty vector to accumulate all locations\n     let count = 0;\n     for (let i = 0; i < boids.length; i++) {\n         let d = p5.Vector.dist(this.position, boids[i].position);\n         if ((d > 0) && (d < neighbordist)) {\n             sum.add(boids[i].position);\n             // Add location\n             count++;\n         }\n     }\n     if (count > 0) {\n         sum.div(count);\n         return this.seek(sum);\n         // Steer towards the location\n     } else {\n         return createVector(0, 0);\n     }\n }"
            },
            {
                "name": "Wolfram CA",
                "description": "Simple demonstration of a Wolfram 1-dimensional cellular automata (natureofcode.com)",
                "code": " let w = 10;\n // An array of 0s and 1s\n let cells;\n // We arbitrarily start with just the middle cell having a state of \"1\"\n let generation = 0;\n // An array to store the ruleset, for example {0,1,1,0,1,1,0,1}\n let ruleset = [0, 1, 0, 1, 1, 0, 1, 0];\n\n function setup() {\n     createCanvas(640, 400);\n     cells = Array(floor(width / w));\n     for (let i = 0; i < cells.length; i++) {\n         cells[i] = 0;\n     }\n     cells[cells.length / 2] = 1;\n }\n\n function draw() {\n     for (let i = 0; i < cells.length; i++) {\n         if (cells[i] === 1) {\n             fill(200);\n         } else {\n             fill(51);\n             noStroke();\n             rect(i * w, generation * w, w, w);\n         }\n     }\n     if (generation < height / w) {\n         generate();\n     }\n }\n // The process of creating the new generation\n function generate() {\n     // First we create an empty array for the new values\n     let nextgen = Array(cells.length);\n     // For every spot, determine new state by examing current state, and neighbor states\n\n     // Ignore edges that only have one neighor\n     for (let i = 1; i < cells.length - 1; i++) {\n         let left = cells[i - 1];\n         // Left neighbor state\n         let me = cells[i];\n         // Current state\n         let right = cells[i + 1];\n         // Right neighbor state\n         nextgen[i] = rules(left, me, right);\n         // Compute next generation state based on ruleset\n     }\n     // The current generation is the new generation\n     cells = nextgen;\n     generation++;\n }\n // Implementing the Wolfram rules\n\n // Could be improved and made more concise, but here we can explicitly see what is going on for each case\n function rules(a, b, c) {\n     if (a == 1 && b == 1 && c == 1) return ruleset[0];\n     if (a == 1 && b == 1 && c == 0) return ruleset[1];\n     if (a == 1 && b == 0 && c == 1) return ruleset[2];\n     if (a == 1 && b == 0 && c == 0) return ruleset[3];\n     if (a == 0 && b == 1 && c == 1) return ruleset[4];\n     if (a == 0 && b == 1 && c == 0) return ruleset[5];\n     if (a == 0 && b == 0 && c == 1) return ruleset[6];\n     if (a == 0 && b == 0 && c == 0) return ruleset[7];\n     return 0;\n }"
            },
            {
                "name": "Game of Life",
                "description": "A basic implementation of John Conway's Game of Life CA (natureofcode.com)",
                "code": " let w;\n let columns;\n let rows;\n let board;\n let next;\n\n function setup() {\n     // Set simulation framerate to 10 to avoid flickering\n     frameRate(10);\n     createCanvas(screenWidth, screenHeight);\n     w = 20;\n     // Calculate columns and rows\n     columns = floor(width / w);\n     rows = floor(height / w);\n     // Wacky way to make a 2D array is JS\n     board = new Array(columns);\n     for (let i = 0; i < columns; i++) {\n         board[i] = new Array(rows);\n     }\n     // Going to use multiple 2D arrays and swap them\n     next = new Array(columns);\n     for (i = 0; i < columns; i++) {\n         next[i] = new Array(rows);\n     }\n     init();\n }\n\n function draw() {\n     background(255);\n     generate();\n     for (let i = 0; i < columns; i++) {\n         for (let j = 0; j < rows; j++) {\n             if ((board[i][j] == 1)) fill(0);\n             else fill(255);\n             stroke(0);\n             rect(i * w, j * w, w - 1, w - 1);\n         }\n     }\n }\n // reset board when mouse is pressed\n function mousePressed() {\n     init();\n }\n // Fill board randomly\n function init() {\n     for (let i = 0; i < columns; i++) {\n         for (let j = 0; j < rows; j++) {\n             // Lining the edges with 0s\n             if (i == 0 || j == 0 || i == columns - 1 || j == rows - 1) board[i][j] = 0;\n             // Filling the rest randomly\n             else board[i][j] = floor(random(2));\n             next[i][j] = 0;\n         }\n     }\n }\n // The process of creating the new generation\n function generate() {\n     // Loop through every spot in our 2D array and check spots neighbors\n     for (let x = 1; x < columns - 1; x++) {\n         for (let y = 1; y < rows - 1; y++) {\n             // Add up all the states in a 3x3 surrounding grid\n             let neighbors = 0;\n             for (let i = -1; i <= 1; i++) {\n                 for (let j = -1; j <= 1; j++) {\n                     neighbors += board[x + i][y + j];\n                 }\n             }\n             // A little trick to subtract the current cell's state since\n\n             // we added it in the above loop\n             neighbors -= board[x][y];\n             // Rules of Life\n             if ((board[x][y] == 1) && (neighbors < 2)) next[x][y] = 0;\n             // Loneliness\n             else if ((board[x][y] == 1) && (neighbors > 3)) next[x][y] = 0;\n             // Overpopulation\n             else if ((board[x][y] == 0) && (neighbors == 3)) next[x][y] = 1;\n             // Reproduction\n             else next[x][y] = board[x][y];\n             // Stasis\n         }\n     }\n     // Swap!\n     let temp = board;\n     board = next;\n     next = temp;\n }"
            },
            {
                "name": "Multiple Particle Systems",
                "description": "Click the mouse to generate a burst of particles at mouse location.\nEach burst is one instance of a particle system with Particles and CrazyParticles (a subclass of Particle).\nNote use of Inheritance and Polymorphism here.\nOriginal by Daniel Shiffman.",
                "code": " let systems;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     systems = [];\n }\n\n function draw() {\n     background(51);\n     background(0);\n     for (i = 0; i < systems.length; i++) {\n         systems[i].run();\n         systems[i].addParticle();\n     }\n     if (systems.length == 0) {\n         fill(255);\n         textAlign(CENTER);\n         textSize(32);\n         text(\"click mouse to add particle systems\", width / 2, height / 2);\n     }\n }\n\n function mousePressed() {\n     this.p = new ParticleSystem(createVector(mouseX, mouseY));\n     systems.push(p);\n }\n // A simple Particle class\n let Particle = function(position) {\n     this.acceleration = createVector(0, 0.05);\n     this.velocity = createVector(random(-1, 1), random(-1, 0));\n     this.position = position.copy();\n     this.lifespan = 255.0;\n };\n Particle.prototype.run = function() {\n     this.update();\n     this.display();\n };\n // Method to update position\n Particle.prototype.update = function() {\n     this.velocity.add(this.acceleration);\n     this.position.add(this.velocity);\n     this.lifespan -= 2;\n };\n // Method to display\n Particle.prototype.display = function() {\n     stroke(200, this.lifespan);\n     strokeWeight(2);\n     fill(127, this.lifespan);\n     ellipse(this.position.x, this.position.y, 12, 12);\n };\n // Is the particle still useful?\n Particle.prototype.isDead = function() {\n     if (this.lifespan < 0) {\n         return true;\n     } else {\n         return false;\n     }\n };\n let ParticleSystem = function(position) {\n     this.origin = position.copy();\n     this.particles = [];\n };\n ParticleSystem.prototype.addParticle = function() {\n     // Add either a Particle or CrazyParticle to the system\n     if (int(random(0, 2)) == 0) {\n         p = new Particle(this.origin);\n     } else {\n         p = new CrazyParticle(this.origin);\n     }\n     this.particles.push(p);\n };\n ParticleSystem.prototype.run = function() {\n     for (let i = this.particles.length - 1; i >= 0; i--) {\n         let p = this.particles[i];\n         p.run();\n         if (p.isDead()) {\n             this.particles.splice(i, 1);\n         }\n     }\n };\n // A subclass of Particle\n function CrazyParticle(origin) {\n     // Call the parent constructor, making sure (using Function#call)\n\n     // that \"this\" is set correctly during the call\n     Particle.call(this, origin);\n     // Initialize our added properties\n     this.theta = 0.0;\n };\n // Create a Crazy.prototype object that inherits from Particle.prototype.\n\n // Note: A common error here is to use \"new Particle()\" to create the\n\n // Crazy.prototype. That's incorrect for several reasons, not least\n\n // that we don't have anything to give Particle for the \"origin\"\n\n // argument. The correct place to call Particle is above, where we call\n\n // it from Crazy.\n CrazyParticle.prototype = Object.create(Particle.prototype);\n // See note below\n\n // Set the \"constructor\" property to refer to CrazyParticle\n CrazyParticle.prototype.constructor = CrazyParticle;\n // Notice we don't have the method run() here; it is inherited from Particle\n\n // This update() method overrides the parent class update() method\n CrazyParticle.prototype.update = function() {\n     Particle.prototype.update.call(this);\n     // Increment rotation based on horizontal velocity\n     this.theta += (this.velocity.x * this.velocity.mag()) / 10.0;\n }\n // This display() method overrides the parent class display() method\n CrazyParticle.prototype.display = function() {\n     // Render the ellipse just like in a regular particle\n     Particle.prototype.display.call(this);\n     // Then add a rotating line\n     push();\n     translate(this.position.x, this.position.y);\n     rotate(this.theta);\n     stroke(255, this.lifespan);\n     line(0, 0, 25, 0);\n     pop();\n }"
            },
            {
                "name": "Spirograph",
                "description": "This sketch uses simple transformations to create a Spirograph-like effect with interlocking circles (called sines). Press the spacebar to switch between tracing and showing the underlying geometry.\nExample created by R. Luke DuBois.\nhttp://en.wikipedia.org/wiki/Spirograph",
                "code": " let NUMSINES = 20;\n // how many of these things can we do at once?\n let sines = new Array(NUMSINES);\n // an array to hold all the current angles\n let rad;\n // an initial radius value for the central sine\n let i;\n // a counter variable\n\n // play with these to get a sense of what's going on:\n let fund = 0.005;\n // the speed of the central sine\n let ratio = 1;\n // what multiplier for speed is each additional sine?\n let alpha = 50;\n // how opaque is the tracing system\n let trace = false;\n // are we tracing?\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     rad = height / 4;\n     // compute radius for central circle\n     background(204);\n     // clear the screen\n     for (let i = 0; i < sines.length; i++) {\n         sines[i] = PI;\n         // start EVERYBODY facing NORTH\n     }\n }\n\n function draw() {\n     if (!trace) {\n         background(204);\n         // clear screen if showing geometry\n         stroke(0, 255);\n         // black pen\n         noFill();\n         // don't fill\n     }\n     // MAIN ACTION\n     push();\n     // start a transformation matrix\n     translate(width / 2, height / 2);\n     // move to middle of screen\n     for (let i = 0; i < sines.length; i++) {\n         let erad = 0;\n         // radius for small \"point\" within circle... this is the 'pen' when tracing\n\n         // setup for tracing\n         if (trace) {\n             stroke(0, 0, 255 * (float(i) / sines.length), alpha);\n             // blue\n             fill(0, 0, 255, alpha / 2);\n             // also, um, blue\n             erad = 5.0 * (1.0 - float(i) / sines.length);\n             // pen width will be related to which sine\n         }\n         let radius = rad / (i + 1);\n         // radius for circle itself\n         rotate(sines[i]);\n         // rotate circle\n         if (!trace) ellipse(0, 0, radius * 2, radius * 2);\n         // if we're simulating, draw the sine\n         push();\n         // go up one level\n         translate(0, radius);\n         // move to sine edge\n         if (!trace) ellipse(0, 0, 5, 5);\n         // draw a little circle\n         if (trace) ellipse(0, 0, erad, erad);\n         // draw with erad if tracing\n         pop();\n         // go down one level\n         translate(0, radius);\n         // move into position for next sine\n         sines[i] = (sines[i] + (fund + (fund * i * ratio))) % TWO_PI;\n         // update angle based on fundamental\n     }\n     pop();\n     // pop down final transformation\n }\n\n function keyReleased() {\n     if (key == ' ') {\n         trace = !trace;\n         background(255);\n     }\n }"
            },
            {
                "name": "L-Systems",
                "description": "This sketch creates an automated drawing based on a Lindenmayer or (L-) system. L-systems are often used in procedural graphics to make natural, geometric, or interesting \"fractal-style\" patterns.\nExample created by R. Luke DuBois.\nhttps://en.wikipedia.org/wiki/L-system",
                "code": " // TURTLE STUFF:\n let x, y;\n // the current position of the turtle\n let currentangle = 0;\n // which way the turtle is pointing\n let step = 20;\n // how much the turtle moves with each 'F'\n let angle = 90;\n // how much the turtle turns with a '-' or '+'\n\n // LINDENMAYER STUFF (L-SYSTEMS)\n let thestring = 'A';\n // \"axiom\" or start of the string\n let numloops = 5;\n // how many iterations to pre-compute\n let therules = [];\n // array for rules\n therules[0] = ['A', '-BF+AFA+FB-'];\n // first rule\n therules[1] = ['B', '+AF-BFB-FA+'];\n // second rule\n let whereinstring = 0;\n // where in the L-system are we?\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     background(255);\n     stroke(0, 0, 0, 255);\n     // start the x and y position at lower-left corner\n     x = 0;\n     y = height - 1;\n     // COMPUTE THE L-SYSTEM\n     for (let i = 0; i < numloops; i++) {\n         thestring = lindenmayer(thestring);\n     }\n }\n\n function draw() {\n     // draw the current character in the string:\n     drawIt(thestring[whereinstring]);\n     // increment the point for where we're reading the string.\n\n     // wrap around at the end.\n     whereinstring++;\n     if (whereinstring > thestring.length - 1) whereinstring = 0;\n }\n // interpret an L-system\n function lindenmayer(s) {\n     let outputstring = '';\n     // start a blank output string\n\n     // iterate through 'therules' looking for symbol matches:\n     for (let i = 0; i < s.length; i++) {\n         let ismatch = 0;\n         // by default, no match\n         for (let j = 0; j < therules.length; j++) {\n             if (s[i] == therules[j][0]) {\n                 outputstring += therules[j][1];\n                 // write substitution\n                 ismatch = 1;\n                 // we have a match, so don't copy over symbol\n                 break;\n                 // get outta this for() loop\n             }\n         }\n         // if nothing matches, just copy the symbol over.\n         if (ismatch == 0) outputstring += s[i];\n     }\n     return outputstring;\n     // send out the modified string\n }\n // this is a custom function that draws turtle commands\n function drawIt(k) {\n     if (k == 'F') {\n         // draw forward\n\n         // polar to cartesian based on step and currentangle:\n         let x1 = x + step * cos(radians(currentangle));\n         let y1 = y + step * sin(radians(currentangle));\n         line(x, y, x1, y1);\n         // connect the old and the new\n\n         // update the turtle's position:\n         x = x1;\n         y = y1;\n     } else if (k == '+') {\n         currentangle += angle;\n         // turn left\n     } else if (k == '-') {\n         currentangle -= angle;\n         // turn right\n     }\n     // give me some random color values:\n     let r = random(128, 255);\n     let g = random(0, 192);\n     let b = random(0, 50);\n     let a = random(50, 100);\n     // pick a gaussian (D&D) distribution for the radius:\n     let radius = 0;\n     radius += random(0, 15);\n     radius += random(0, 15);\n     radius += random(0, 15);\n     radius = radius / 3;\n     // draw the stuff:\n     fill(r, g, b, a);\n     ellipse(x, y, radius, radius);\n }"
            },
            {
                "name": "Spring",
                "description": "Click, drag, and release the horizontal bar to start the spring.",
                "code": " // Spring drawing constants for top bar\n let springHeight = 32,\n     left, right, maxHeight = 200,\n     minHeight = 100,\n     over = false,\n     move = false;\n // Spring simulation constants\n let M = 0.8,\n     // Mass\n     K = 0.2,\n     // Spring constant\n     D = 0.92,\n     // Damping\n     R = 150;\n // Rest position\n\n // Spring simulation variables\n let ps = R,\n     // Position\n     vs = 0.0,\n     // Velocity\n     as = 0,\n     // Acceleration\n     f = 0;\n // Force\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     rectMode(CORNERS);\n     noStroke();\n     left = width / 2 - 100;\n     right = width / 2 + 100;\n }\n\n function draw() {\n     background(102);\n     updateSpring();\n     drawSpring();\n }\n\n function drawSpring() {\n     // Draw base\n     fill(0.2);\n     let baseWidth = 0.5 * ps + -8;\n     rect(width / 2 - baseWidth, ps + springHeight, width / 2 + baseWidth, height);\n     // Set color and draw top bar\n     if (over || move) {\n         fill(255);\n     } else {\n         fill(204);\n     }\n     rect(left, ps, right, ps + springHeight);\n }\n\n function updateSpring() {\n     // Update the spring position\n     if (!move) {\n         f = -K * (ps - R);\n         // f=-ky\n         as = f / M;\n         // Set the acceleration, f=ma == a=f/m\n         vs = D * (vs + as);\n         // Set the velocity\n         ps = ps + vs;\n         // Updated position\n     }\n     if (abs(vs) < 0.1) {\n         vs = 0.0;\n     }\n     // Test if mouse if over the top bar\n     if (mouseX > left && mouseX < right && mouseY > ps && mouseY < ps + springHeight) {\n         over = true;\n     } else {\n         over = false;\n     }\n     // Set and constrain the position of top bar\n     if (move) {\n         ps = mouseY - springHeight / 2;\n         ps = constrain(ps, minHeight, maxHeight);\n     }\n }\n\n function mousePressed() {\n     if (over) {\n         move = true;\n     }\n }\n\n function mouseReleased() {\n     move = false;\n }"
            },
            {
                "name": "Springs",
                "description": "Move the mouse over one of the circles and click to re-position. When you release the mouse, it will snap back into position. Each circle has a slightly different behavior.\n\nThis example is ported from the Processing website",
                "code": " let num = 3;\n let springs = [];\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     noStroke();\n     springs[0] = new Spring(240, 260, 40, 0.98, 8.0, 0.1, springs, 0);\n     springs[1] = new Spring(320, 210, 120, 0.95, 9.0, 0.1, springs, 1);\n     springs[2] = new Spring(180, 170, 200, 0.90, 9.9, 0.1, springs, 2);\n }\n\n function draw() {\n     background(51);\n     for (let i = 0; i < num; i++) {\n         springs[i].update();\n         springs[i].display();\n     }\n }\n\n function mousePressed() {\n     for (let i = 0; i < num; i++) {\n         springs[i].pressed();\n     }\n }\n\n function mouseReleased() {\n     for (let i = 0; i < num; i++) {\n         springs[i].released();\n     }\n }\n // Spring class\n function Spring(_x, _y, _s, _d, _m, _k_in, _others, _id) {\n     // Screen values\n\n     // this.xpos = _x;\n\n     // this.ypos = _y;\n     this.x_pos = _x;\n     this.y_pos = _y;\n     this.size = 20;\n     this.size = _s;\n     this.over = false;\n     this.move = false;\n     // Spring simulation constants\n     this.mass = _m;\n     // Mass\n     this.k = 0.2;\n     // Spring constant\n     this.k = _k_in;\n     this.damp = _d;\n     // Damping\n     this.rest_posx = _x;\n     // Rest position X\n     this.rest_posy = _y;\n     // Rest position Y\n\n     // Spring simulation variables\n\n     //float pos = 20.0;   // Position\n     this.velx = 0.0;\n     // X Velocity\n     this.vely = 0.0;\n     // Y Velocity\n     this.accel = 0;\n     // Acceleration\n     this.force = 0;\n     // Force\n     this.friends = _others;\n     this.id = _id;\n     this.update = function() {\n         if (this.move) {\n             this.rest_posy = mouseY;\n             this.rest_posx = mouseX;\n         }\n         this.force = -this.k * (this.y_pos - this.rest_posy);\n         // f=-ky\n         this.accel = this.force / this.mass;\n         // Set the acceleration, f=ma == a=f/m\n         this.vely = this.damp * (this.vely + this.accel);\n         // Set the velocity\n         this.y_pos = this.y_pos + this.vely;\n         // Updated position\n         this.force = -this.k * (this.x_pos - this.rest_posx);\n         // f=-ky\n         this.accel = this.force / this.mass;\n         // Set the acceleration, f=ma == a=f/m\n         this.velx = this.damp * (this.velx + this.accel);\n         // Set the velocity\n         this.x_pos = this.x_pos + this.velx;\n         // Updated position\n         if ((this.overEvent() || this.move) && !(this.otherOver())) {\n             this.over = true;\n         } else {\n             this.over = false;\n         }\n     }\n     // Test to see if mouse is over this spring\n     this.overEvent = function() {\n         let disX = this.x_pos - mouseX;\n         let disY = this.y_pos - mouseY;\n         let dis = createVector(disX, disY);\n         if (dis.mag() < this.size / 2) {\n             return true;\n         } else {\n             return false;\n         }\n     }\n     // Make sure no other springs are active\n     this.otherOver = function() {\n         for (let i = 0; i < num; i++) {\n             if (i != this.id) {\n                 if (this.friends[i].over == true) {\n                     return true;\n                 }\n             }\n         }\n         return false;\n     }\n     this.display = function() {\n         if (this.over) {\n             fill(153);\n         } else {\n             fill(255);\n         }\n         ellipse(this.x_pos, this.y_pos, this.size, this.size);\n     }\n     this.pressed = function() {\n         if (this.over) {\n             this.move = true;\n         } else {\n             this.move = false;\n         }\n     }\n     this.released = function() {\n         this.move = false;\n         this.rest_posx = this.y_pos;\n         this.rest_posy = this.y_pos;\n     }\n };"
            },
            {
                "name": "Soft Body",
                "description": "Original example by Ira Greenberg.\n\nSoftbody dynamics simulation using curveVertex() and curveTightness().",
                "code": " // center point\n let centerX = 0.0,\n     centerY = 0.0;\n let radius = 45,\n     rotAngle = -90;\n let accelX = 0.0,\n     accelY = 0.0;\n let deltaX = 0.0,\n     deltaY = 0.0;\n let springing = 0.0009,\n     damping = 0.98;\n //corner nodes\n let nodes = 5;\n //zero fill arrays\n let nodeStartX = [];\n let nodeStartY = [];\n let nodeX = [];\n let nodeY = [];\n let angle = [];\n let frequency = [];\n // soft-body dynamics\n let organicConstant = 1.0;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     //center shape in window\n     centerX = width / 2;\n     centerY = height / 2;\n     //initialize arrays to 0\n     for (let i = 0; i < nodes; i++) {\n         nodeStartX[i] = 0;\n         nodeStartY[i] = 0;\n         nodeY[i] = 0;\n         nodeY[i] = 0;\n         angle[i] = 0;\n     }\n     // iniitalize frequencies for corner nodes\n     for (let i = 0; i < nodes; i++) {\n         frequency[i] = random(5, 12);\n     }\n     noStroke();\n     frameRate(30);\n }\n\n function draw() {\n     //fade background\n     fill(0, 100);\n     rect(0, 0, width, height);\n     drawShape();\n     moveShape();\n }\n\n function drawShape() {\n     //  calculate node  starting locations\n     for (let i = 0; i < nodes; i++) {\n         nodeStartX[i] = centerX + cos(radians(rotAngle)) * radius;\n         nodeStartY[i] = centerY + sin(radians(rotAngle)) * radius;\n         rotAngle += 360.0 / nodes;\n     }\n     // draw polygon\n     curveTightness(organicConstant);\n     fill(255);\n     beginShape();\n     for (let i = 0; i < nodes; i++) {\n         curveVertex(nodeX[i], nodeY[i]);\n     }\n     for (let i = 0; i < nodes - 1; i++) {\n         curveVertex(nodeX[i], nodeY[i]);\n     }\n     endShape(CLOSE);\n }\n\n function moveShape() {\n     //move center point\n     deltaX = mouseX - centerX;\n     deltaY = mouseY - centerY;\n     // create springing effect\n     deltaX *= springing;\n     deltaY *= springing;\n     accelX += deltaX;\n     accelY += deltaY;\n     // move predator's center\n     centerX += accelX;\n     centerY += accelY;\n     // slow down springing\n     accelX *= damping;\n     accelY *= damping;\n     // change curve tightness\n     organicConstant = 1 - ((abs(accelX) + abs(accelY)) * 0.1);\n     //move nodes\n     for (let i = 0; i < nodes; i++) {\n         nodeX[i] = nodeStartX[i] + sin(radians(angle[i])) * (accelX * 2);\n         nodeY[i] = nodeStartY[i] + sin(radians(angle[i])) * (accelY * 2);\n         angle[i] += frequency[i];\n     }\n }"
            },
            {
                "name": "SmokeParticles",
                "description": "a port of Dan Shiffman's SmokeParticleSystem example originally for Processing. Creates smokey particles :p",
                "code": " // texture for the particle\n let particle_texture = null;\n // variable holding our particle system\n let ps = null;\n\n function preload() {\n     particle_texture = loadImage(\"assets/particle_texture.png\");\n }\n\n function setup() {\n     //set the canvas size\n     createCanvas(screenWidth, screenHeight);\n     //initialize our particle system\n     ps = new ParticleSystem(0, createVector(width / 2, height - 60), particle_texture);\n }\n\n function draw() {\n     background(0);\n     let dx = map(mouseX, 0, width, -0.2, 0.2);\n     let wind = createVector(dx, 0);\n     ps.applyForce(wind);\n     ps.run();\n     for (let i = 0; i < 2; i++) {\n         ps.addParticle();\n     }\n     // Draw an arrow representing the wind force\n     drawVector(wind, createVector(width / 2, 50, 0), 500);\n }\n /**\n  \n  *  This function draws an arrow showing the direction our \"wind\" is blowing.\n  \n  */\n function drawVector(v, loc, scale) {\n     push();\n     let arrowsize = 4;\n     translate(loc.x, loc.y);\n     stroke(255);\n     rotate(v.heading());\n     let len = v.mag() * scale;\n     line(0, 0, len, 0);\n     line(len, 0, len - arrowsize, +arrowsize / 2);\n     line(len, 0, len - arrowsize, -arrowsize / 2);\n     pop();\n }\n //========= PARTICLE SYSTEM ===========\n\n /**\n  \n  * A basic particle system class\n  \n  * \n  \n @param\n  \n  num the number of particles\n  \n  * \n  \n @param\n  \n  v the origin of the particle system\n  \n  * \n  \n @param\n  \n  img_ a texture for each particle in the system\n  \n  * \n  \n @constructor\n  \n  */\n let ParticleSystem = function(num, v, img_) {\n     this.particles = [];\n     this.origin = v.copy();\n     // we make sure to copy the vector value in case we accidentally mutate the original by accident\n     this.img = img_\n     for (let i = 0; i < num; ++i) {\n         this.particles.push(new Particle(this.origin, this.img));\n     }\n };\n /**\n  \n  * This function runs the entire particle system.\n  \n  */\n ParticleSystem.prototype.run = function() {\n     // cache length of the array we're going to loop into a variable\n\n     // You may see <variable>.length in a for loop, from time to time but\n\n     // we cache it here because otherwise the length is re-calculated for each iteration of a loop\n     let len = this.particles.length;\n     //loop through and run particles\n     for (let i = len - 1; i >= 0; i--) {\n         let particle = this.particles[i];\n         particle.run();\n         // if the particle is dead, we remove it.\n\n         // javascript arrays don't have a \"remove\" function but \"splice\" works just as well.\n\n         // we feed it an index to start at, then how many numbers from that point to remove.\n         if (particle.isDead()) {\n             this.particles.splice(i, 1);\n         }\n     }\n }\n /**\n  \n  * Method to add a force vector to all particles currently in the system\n  \n  * \n  \n @param\n  \n  dir a p5.Vector describing the direction of the force.\n  \n  */\n ParticleSystem.prototype.applyForce = function(dir) {\n     let len = this.particles.length;\n     for (let i = 0; i < len; ++i) {\n         this.particles[i].applyForce(dir);\n     }\n }\n /**\n  \n  * Adds a new particle to the system at the origin of the system and with\n  \n  * the originally set texture.\n  \n  */\n ParticleSystem.prototype.addParticle = function() {\n     this.particles.push(new Particle(this.origin, this.img));\n }\n //========= PARTICLE  ===========\n\n /**\n  \n  *  A simple Particle class, renders the particle as an image\n  \n  */\n let Particle = function(pos, img_) {\n     this.loc = pos.copy();\n     let vx = randomGaussian() * 0.3;\n     let vy = randomGaussian() * 0.3 - 1.0;\n     this.vel = createVector(vx, vy);\n     this.acc = createVector();\n     this.lifespan = 100.0;\n     this.texture = img_;\n }\n /**\n  \n  *  Simulataneously updates and displays a particle.\n  \n  */\n Particle.prototype.run = function() {\n     this.update();\n     this.render();\n }\n /**\n  \n  *  A function to display a particle\n  \n  */\n Particle.prototype.render = function() {\n     imageMode(CENTER);\n     tint(255, this.lifespan);\n     image(this.texture, this.loc.x, this.loc.y);\n }\n /**\n  \n  *  A method to apply a force vector to a particle.\n  \n  */\n Particle.prototype.applyForce = function(f) {\n     this.acc.add(f);\n }\n /**\n  \n  *  This method checks to see if the particle has reached the end of it's lifespan,\n  \n  *  if it has, return true, otherwise return false.\n  \n  */\n Particle.prototype.isDead = function() {\n     if (this.lifespan <= 0.0) {\n         return true;\n     } else {\n         return false;\n     }\n }\n /**\n  \n  *  This method updates the position of the particle.\n  \n  */\n Particle.prototype.update = function() {\n     this.vel.add(this.acc);\n     this.loc.add(this.vel);\n     this.lifespan -= 2.5;\n     this.acc.mult(0);\n }"
            },
            {
                "name": "Brownian Motion",
                "description": "Recording random movement as a continuous line. Port of original example from the Processing examples page.",
                "code": " let num = 2000;\n let range = 6;\n let ax = [];\n let ay = [];\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     for (let i = 0; i < num; i++) {\n         ax[i] = width / 2;\n         ay[i] = height / 2;\n     }\n     frameRate(30);\n }\n\n function draw() {\n     background(51);\n     // Shift all elements 1 place to the left\n     for (let i = 1; i < num; i++) {\n         ax[i - 1] = ax[i];\n         ay[i - 1] = ay[i];\n     }\n     // Put a new value at the end of the array\n     ax[num - 1] += random(-range, range);\n     ay[num - 1] += random(-range, range);\n     // Constrain all points to the screen\n     ax[num - 1] = constrain(ax[num - 1], 0, width);\n     ay[num - 1] = constrain(ay[num - 1], 0, height);\n     // Draw a line connecting the points\n     for (let j = 1; j < num; j++) {\n         let val = j / num * 204.0 + 51;\n         stroke(val);\n         line(ax[j - 1], ay[j - 1], ax[j], ay[j]);\n     }\n }"
            },
            {
                "name": "Chain",
                "description": "One mass is attached to the mouse position and the other is attached the position of the other mass. The gravity in the environment pulls down on both.\n\nThis example is ported from the Processing website",
                "code": " let s1, s2;\n let gravity = 9.0;\n let mass = 2.0;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     fill(255, 126);\n     // Inputs: x, y, mass, gravity\n     s1 = new Spring2D(0.0, width / 2, mass, gravity);\n     s2 = new Spring2D(0.0, width / 2, mass, gravity);\n }\n\n function draw() {\n     background(0);\n     s1.update(mouseX, mouseY);\n     s1.display(mouseX, mouseY);\n     s2.update(s1.x, s1.y);\n     s2.display(s1.x, s1.y);\n }\n\n function Spring2D(xpos, ypos, m, g) {\n     this.x = xpos;\n     // The x- and y-coordinates\n     this.y = ypos;\n     this.vx = 0;\n     // The x- and y-axis velocities\n     this.vy = 0;\n     this.mass = m;\n     this.gravity = g;\n     this.radius = 30;\n     this.stiffness = 0.2;\n     this.damping = 0.7;\n     this.update = function(targetX, targetY) {\n         let forceX = (targetX - this.x) * this.stiffness;\n         let ax = forceX / this.mass;\n         this.vx = this.damping * (this.vx + ax);\n         this.x += this.vx;\n         let forceY = (targetY - this.y) * this.stiffness;\n         forceY += this.gravity;\n         let ay = forceY / this.mass;\n         this.vy = this.damping * (this.vy + ay);\n         this.y += this.vy;\n     }\n     this.display = function(nx, ny) {\n         noStroke();\n         ellipse(this.x, this.y, this.radius * 2, this.radius * 2);\n         stroke(255);\n         line(this.x, this.y, nx, ny);\n     }\n }"
            },
            {
                "name": "Snowflakes",
                "description": "Particle system simulating the motion of falling snowflakes. Uses an array of objects to hold the snowflake particles. Contributed by Aatish Bhatia.",
                "code": " let snowflakes = [];\n // array to hold snowflake objects\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     fill(240);\n     noStroke();\n }\n\n function draw() {\n     background('brown');\n     let t = frameCount / 60;\n     // update time\n\n     // create a random number of snowflakes each frame\n     for (let i = 0; i < random(5); i++) {\n         snowflakes.push(new snowflake());\n         // append snowflake object\n     }\n     // loop through snowflakes with a for..of loop\n     for (let flake of snowflakes) {\n         flake.update(t);\n         // update snowflake position\n         flake.display();\n         // draw snowflake\n     }\n }\n // snowflake class\n function snowflake() {\n     // initialize coordinates\n     this.posX = 0;\n     this.posY = random(-50, 0);\n     this.initialangle = random(0, 2 * PI);\n     this.size = random(2, 5);\n     // radius of snowflake spiral\n\n     // chosen so the snowflakes are uniformly spread out in area\n     this.radius = sqrt(random(pow(width / 2, 2)));\n     this.update = function(time) {\n         // x position follows a circle\n         let w = 0.6;\n         // angular speed\n         let angle = w * time + this.initialangle;\n         this.posX = width / 2 + this.radius * sin(angle);\n         // different size snowflakes fall at slightly different y speeds\n         this.posY += pow(this.size, 0.5);\n         // delete snowflake if past end of screen\n         if (this.posY > height) {\n             let index = snowflakes.indexOf(this);\n             snowflakes.splice(index, 1);\n         }\n     };\n     this.display = function() {\n         ellipse(this.posX, this.posY, this.size);\n     };\n }"
            },
            {
                "name": "Penrose Tiles",
                "description": "This is a port by David Blitz of the \"Penrose Tile\" example from processing.org/examples",
                "code": " let ds;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     ds = new PenroseLSystem();\n     //please, play around with the following line\n     ds.simulate(5);\n }\n\n function draw() {\n     background(0);\n     ds.render();\n }\n\n function PenroseLSystem() {\n     this.steps = 0;\n     //these are axiom and rules for the penrose rhombus l-system\n\n     //a reference would be cool, but I couldn't find a good one\n     this.axiom = \"[X]++[X]++[X]++[X]++[X]\";\n     this.ruleW = \"YF++ZF----XF[-YF----WF]++\";\n     this.ruleX = \"+YF--ZF[---WF--XF]+\";\n     this.ruleY = \"-WF++XF[+++YF++ZF]-\";\n     this.ruleZ = \"--YF++++WF[+ZF++++XF]--XF\";\n     //please play around with the following two lines\n     this.startLength = 460.0;\n     this.theta = TWO_PI / 10.0;\n     //36 degrees, try TWO_PI / 6.0, ...\n     this.reset();\n }\n PenroseLSystem.prototype.simulate = function(gen) {\n     while (this.getAge() < gen) {\n         this.iterate(this.production);\n     }\n }\n PenroseLSystem.prototype.reset = function() {\n     this.production = this.axiom;\n     this.drawLength = this.startLength;\n     this.generations = 0;\n }\n PenroseLSystem.prototype.getAge = function() {\n     return this.generations;\n }\n //apply substitution rules to create new iteration of production string\n PenroseLSystem.prototype.iterate = function() {\n     let newProduction = \"\";\n     for (let i = 0; i < this.production.length; ++i) {\n         let step = this.production.charAt(i);\n         //if current character is 'W', replace current character\n\n         //by corresponding rule\n         if (step == 'W') {\n             newProduction = newProduction + this.ruleW;\n         } else if (step == 'X') {\n             newProduction = newProduction + this.ruleX;\n         } else if (step == 'Y') {\n             newProduction = newProduction + this.ruleY;\n         } else if (step == 'Z') {\n             newProduction = newProduction + this.ruleZ;\n         } else {\n             //drop all 'F' characters, don't touch other\n\n             //characters (i.e. '+', '-', '[', ']'\n             if (step != 'F') {\n                 newProduction = newProduction + step;\n             }\n         }\n     }\n     this.drawLength = this.drawLength * 0.5;\n     this.generations++;\n     this.production = newProduction;\n }\n //convert production string to a turtle graphic\n PenroseLSystem.prototype.render = function() {\n     translate(width / 2, height / 2);\n     this.steps += 20;\n     if (this.steps > this.production.length) {\n         this.steps = this.production.length;\n     }\n     for (let i = 0; i < this.steps; ++i) {\n         let step = this.production.charAt(i);\n         //'W', 'X', 'Y', 'Z' symbols don't actually correspond to a turtle action\n         if (step == 'F') {\n             stroke(255, 60);\n             for (let j = 0; j < this.repeats; j++) {\n                 line(0, 0, 0, -this.drawLength);\n                 noFill();\n                 translate(0, -this.drawLength);\n             }\n             this.repeats = 1;\n         } else if (step == '+') {\n             rotate(this.theta);\n         } else if (step == '-') {\n             rotate(-this.theta);\n         } else if (step == '[') {\n             push();\n         } else if (step == ']') {\n             pop();\n         }\n     }\n }"
            },
            {
                "name": "Recursive Tree",
                "description": "Renders a simple tree-like structure via recursion. The branching angle is calculated as a function of the horizontal mouse location. Move the mouse left and right to change the angle. Based on Daniel Shiffman's Recursive Tree Example for Processing.",
                "code": " let theta;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n }\n\n function draw() {\n     background(0);\n     frameRate(30);\n     stroke(255);\n     // Let's pick an angle 0 to 90 degrees based on the mouse position\n     let a = (mouseX / width) * 90;\n     // Convert it to radians\n     theta = radians(a);\n     // Start the tree from the bottom of the screen\n     translate(width / 2, height);\n     // Draw a line 120 pixels\n     line(0, 0, 0, -120);\n     // Move to the end of that line\n     translate(0, -120);\n     // Start the recursive branching!\n     branch(120);\n }\n\n function branch(h) {\n     // Each branch will be 2/3rds the size of the previous one\n     h *= 0.66;\n     // All recursive functions must have an exit condition!!!!\n\n     // Here, ours is when the length of the branch is 2 pixels or less\n     if (h > 2) {\n         push();\n         // Save the current state of transformation (i.e. where are we now)\n         rotate(theta);\n         // Rotate by theta\n         line(0, 0, 0, -h);\n         // Draw the branch\n         translate(0, -h);\n         // Move to the end of the branch\n         branch(h);\n         // Ok, now call myself to draw two new branches!!\n         pop();\n         // Whenever we get back here, we \"pop\" in order to restore the previous matrix state\n\n         // Repeat the same thing, only branch off to the \"left\" this time!\n         push();\n         rotate(-theta);\n         line(0, 0, 0, -h);\n         translate(0, -h);\n         branch(h);\n         pop();\n     }\n }"
            },
            {
                "name": "The Mandelbrot Set",
                "description": "Simple rendering of the Mandelbrot set. Based on Daniel Shiffman's Mandelbrot Example for Processing.",
                "code": " function setup() {\n     createCanvas(screenWidth, screenHeight);\n     pixelDensity(1);\n     noLoop();\n }\n\n function draw() {\n     background(0);\n     // Establish a range of values on the complex plane\n\n     // A different range will allow us to \"zoom\" in or out on the fractal\n\n     // It all starts with the width, try higher or lower values\n     const w = 4;\n     const h = (w * height) / width;\n     // Start at negative half the width and height\n     const xmin = -w / 2;\n     const ymin = -h / 2;\n     // Make sure we can write to the pixels[] array.\n\n     // Only need to do this once since we don't do any other drawing.\n     loadPixels();\n     // Maximum number of iterations for each point on the complex plane\n     const maxiterations = 100;\n     // x goes from xmin to xmax\n     const xmax = xmin + w;\n     // y goes from ymin to ymax\n     const ymax = ymin + h;\n     // Calculate amount we increment x,y for each pixel\n     const dx = (xmax - xmin) / (width);\n     const dy = (ymax - ymin) / (height);\n     // Start y\n     let y = ymin;\n     for (let j = 0; j < height; j++) {\n         // Start x\n         let x = xmin;\n         for (let i = 0; i < width; i++) {\n             // Now we test, as we iterate z = z^2 + cm does z tend towards infinity?\n             let a = x;\n             let b = y;\n             let n = 0;\n             while (n < maxiterations) {\n                 const aa = a * a;\n                 const bb = b * b;\n                 const twoab = 2.0 * a * b;\n                 a = aa - bb + x;\n                 b = twoab + y;\n                 // Infinty in our finite world is simple, let's just consider it 16\n                 if (dist(aa, bb, 0, 0) > 16) {\n                     break;\n                     // Bail\n                 }\n                 n++;\n             }\n             // We color each pixel based on how long it takes to get to infinity\n\n             // If we never got there, let's pick the color black\n             const pix = (i + j * width) * 4;\n             const norm = map(n, 0, maxiterations, 0, 1);\n             let bright = map(sqrt(norm), 0, 1, 0, 255);\n             if (n == maxiterations) {\n                 bright = 0;\n             } else {\n                 // Gosh, we could make fancy colors here if we wanted\n                 pixels[pix + 0] = bright;\n                 pixels[pix + 1] = bright;\n                 pixels[pix + 2] = bright;\n                 pixels[pix + 3] = 255;\n             }\n             x += dx;\n         }\n         y += dy;\n     }\n     updatePixels();\n }"
            },
            {
                "name": "Koch Curve",
                "description": "Renders a simple fractal, the Koch snowflake. Each recursive level is drawn in sequence. By Daniel Shiffman",
                "code": " let k;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     frameRate(1);\n     // Animate slowly\n     k = new KochFractal();\n }\n\n function draw() {\n     background(0);\n     // Draws the snowflake!\n     k.render();\n     // Iterate\n     k.nextLevel();\n     // Let's not do it more than 5 times. . .\n     if (k.getCount() > 5) {\n         k.restart();\n     }\n }\n // A class to describe one line segment in the fractal\n\n // Includes methods to calculate midp5.Vectors along the line according to the Koch algorithm\n class KochLine {\n     constructor(a, b) {\n         // Two p5.Vectors,\n\n         // start is the \"left\" p5.Vector and\n\n         // end is the \"right p5.Vector\n         this.start = a.copy();\n         this.end = b.copy();\n     }\n     display() {\n         stroke(255);\n         line(this.start.x, this.start.y, this.end.x, this.end.y);\n     }\n     kochA() {\n         return this.start.copy();\n     }\n     // This is easy, just 1/3 of the way\n     kochB() {\n         let v = p5.Vector.sub(this.end, this.start);\n         v.div(3);\n         v.add(this.start);\n         return v;\n     }\n     // More complicated, have to use a little trig to figure out where this p5.Vector is!\n     kochC() {\n         let a = this.start.copy();\n         // Start at the beginning\n         let v = p5.Vector.sub(this.end, this.start);\n         v.div(3);\n         a.add(v);\n         // Move to point B\n         v.rotate(-PI / 3);\n         // Rotate 60 degrees\n         a.add(v);\n         // Move to point C\n         return a;\n     }\n     // Easy, just 2/3 of the way\n     kochD() {\n         let v = p5.Vector.sub(this.end, this.start);\n         v.mult(2 / 3.0);\n         v.add(this.start);\n         return v;\n     }\n     kochE() {\n         return this.end.copy();\n     }\n }\n // A class to manage the list of line segments in the snowflake pattern\n class KochFractal {\n     constructor() {\n         this.start = createVector(0, height - 20);\n         // A p5.Vector for the start\n         this.end = createVector(width, height - 20);\n         // A p5.Vector for the end\n         this.lines = [];\n         // An array to keep track of all the lines\n         this.count = 0;\n         this.restart();\n     }\n     nextLevel() {\n         // For every line that is in the arraylist\n\n         // create 4 more lines in a new arraylist\n         this.lines = this.iterate(this.lines);\n         this.count++;\n     }\n     restart() {\n         this.count = 0;\n         // Reset count\n         this.lines = [];\n         // Empty the array list\n         this.lines.push(new KochLine(this.start, this.end));\n         // Add the initial line (from one end p5.Vector to the other)\n     }\n     getCount() {\n         return this.count;\n     }\n     // This is easy, just draw all the lines\n     render() {\n         for (let i = 0; i < this.lines.length; i++) {\n             this.lines[i].display();\n         }\n     }\n     // This is where the **MAGIC** happens\n\n     // Step 1: Create an empty arraylist\n\n     // Step 2: For every line currently in the arraylist\n\n     //   - calculate 4 line segments based on Koch algorithm\n\n     //   - add all 4 line segments into the new arraylist\n\n     // Step 3: Return the new arraylist and it becomes the list of line segments for the structure\n\n     // As we do this over and over again, each line gets broken into 4 lines, which gets broken into 4 lines, and so on. . .\n     iterate(before) {\n         let now = [];\n         // Create emtpy list\n         for (let i = 0; i < this.lines.length; i++) {\n             let l = this.lines[i];\n             // Calculate 5 koch p5.Vectors (done for us by the line object)\n             let a = l.kochA();\n             let b = l.kochB();\n             let c = l.kochC();\n             let d = l.kochD();\n             let e = l.kochE();\n             // Make line segments between all the p5.Vectors and add them\n             now.push(new KochLine(a, b));\n             now.push(new KochLine(b, c));\n             now.push(new KochLine(c, d));\n             now.push(new KochLine(d, e));\n         }\n         return now;\n     }\n }"
            },
            {
                "name": "Bubble Sort",
                "description": "Sorts the randomly distributed bars according to their height in ascending order while simulating the whole sorting process. Took references from Coding Challenge by The Coding Train.",
                "code": ""
            },
            {
                "name": "Stepping Feet Illusion",
                "description": "Stepping feet illusion is a very famous psychological experiment Both the bricks will appear to move at different speed even though they are moving at the same speed. Click the mouse inside Canvas to confirm that they are moving at the same speed. Contributed by Sagar Arora.",
                "code": " // this class describes the structure\n\n // and movements of the brick\n class Brick {\n     constructor(bc, y) {\n         this.brickColor = bc;\n         this.yPos = y;\n         this.xPos = 0;\n     }\n     // this function creates the brick\n     createBrick() {\n         fill(this.brickColor);\n         rect(this.xPos, this.yPos, 100, 50);\n     }\n     // this function sets the speed\n\n     // of movement of the brick to 1\n     setSpeed() {\n         this.xSpeed = 1;\n     }\n     // this function sets the bricks in motion\n     moveBrick() {\n         this.xPos += this.xSpeed;\n         if (this.xPos + 100 >= width || this.xPos <= 0) {\n             this.xSpeed *= -1;\n         }\n     }\n }\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     createP(\"Keep the mouse clicked\").style('color', '#ffffff');\n     createP(\"to check whether the bricks\").style('color', '#ffffff');\n     createP(\"are moving at same speed or not\").style('color', '#ffffff');\n }\n // creating two bricks of \n\n // colors white and black\n let brick1 = new Brick(\"white\", 100);\n let brick2 = new Brick(\"black\", 250);\n // This function sets speed of\n\n // brick 1 and brick2 to 1.\n brick1.setSpeed();\n brick2.setSpeed();\n\n function draw() {\n     background(0);\n     if (mouseIsPressed) {\n         background(50);\n     }\n     brick1.createBrick();\n     brick1.moveBrick();\n     if (!mouseIsPressed) {\n         createBars();\n     }\n     brick2.createBrick();\n     brick2.moveBrick();\n }\n // this function creates the black and\n\n // white bars across the screen\n function createBars() {\n     let len = 12;\n     for (let i = 0; i < width / len; i++) {\n         fill(\"white\");\n         if (i % 2 === 0) rect(i * len, height, len, -height);\n     }\n }"
            },
            {
                "name": "Particles",
                "description": "There is a light-weight JavaScript library named particle.js which creates a very pleasing particle system. This is an attempt to recreate that particle system using p5.js. Inspired by Particle.js, contributed by Sagar Arora.",
                "code": " // this class describes the properties of a single particle.\n class Particle {\n     // setting the co-ordinates, radius and the\n\n     // speed of a particle in both the co-ordinates axes.\n     constructor() {\n         this.x = random(0, width);\n         this.y = random(0, height);\n         this.r = random(1, 8);\n         this.xSpeed = random(-2, 2);\n         this.ySpeed = random(-1, 1.5);\n     }\n     // creation of a particle.\n     createParticle() {\n         noStroke();\n         fill('rgba(200,169,169,0.5)');\n         circle(this.x, this.y, this.r);\n     }\n     // setting the particle in motion.\n     moveParticle() {\n         if (this.x < 0 || this.x > width) this.xSpeed *= -1;\n         if (this.y < 0 || this.y > height) this.ySpeed *= -1;\n         this.x += this.xSpeed;\n         this.y += this.ySpeed;\n     }\n     // this function creates the connections(lines)\n\n     // between particles which are less than a certain distance apart\n     joinParticles(particles) {\n         particles.forEach(element => {\n             let dis = dist(this.x, this.y, element.x, element.y);\n             if (dis < 85) {\n                 stroke('rgba(255,255,255,0.04)');\n                 line(this.x, this.y, element.x, element.y);\n             }\n         });\n     }\n }\n // an array to add multiple particles\n let particles = [];\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     for (let i = 0; i < width / 10; i++) {\n         particles.push(new Particle());\n     }\n }\n\n function draw() {\n     background('#0f0f0f');\n     for (let i = 0; i < particles.length; i++) {\n         particles[i].createParticle();\n         particles[i].moveParticle();\n         particles[i].joinParticles(particles.slice(i));\n     }\n }"
            },
            {
                "name": "Quicksort",
                "description": "This is a simulation of the Quicksort sorting algorithm. We start with an array of bars and sort them according to their height in ascending order. References taken from a coding challenge by The Coding Train.\n\nQuicksort is a divide-and-conquer algorithm: it performs sorting by dividing the original array into smaller subarrays and solving them independently, loosely speaking. It involves picking an element of the array as the pivot element and partitioning the given array around the picked pivot.\nPartitioning refers to arranging the given array(or subarray) in such a way that all elements to the left of the pivot element are smaller than it and all elements to its right are larger than it. Thus, we have a reference point from where we proceed to sort the left and right 'halves' of the array, and eventually arrive at an array sorted in ascending order. More\n",
                "code": " // width of each bar is taken as 8.\n let values = [];\n // The array 'states' helps in identifying the pivot index\n\n // at every step, and also the subarray which is being sorted\n\n // at any given time. \n let states = [];\n // The setup() function is called once when the program \n\n // starts. Here, we fill the array 'values' with random values\n\n // and the array 'states' with a value of -1 for each position.\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     for (let i = 0; i < width / 8; i++) {\n         values.push(random(height));\n         states.push(-1);\n     }\n     quickSort(0, values.length - 1);\n }\n // The statements in draw() function are executed continuously\n\n // until the program is stopped. Each statement is executed\n\n // sequentially and after the last line is read, the first\n\n // line is executed again.\n function draw() {\n     background(140);\n     for (let i = 0; i < values.length; i++) {\n         // color coding\n         if (states[i] == 0) {\n             // color for the bar at the pivot index\n             fill('#E0777D');\n         } else if (states[i] == 1) {\n             // color for the bars being sorted currently\n             fill('#D6FFB7');\n         } else {\n             fill(255);\n         }\n         rect(i * 8, height - values[i], 8, values[i]);\n     }\n }\n async function quickSort(start, end) {\n     if (start > end) {\n         // Nothing to sort!\n         return;\n     }\n     // partition() returns the index of the pivot element.\n\n     // Once partition() is executed, all elements to the  \n\n     // left of the pivot element are smaller than it and \n\n     // all elements to its right are larger than it.\n     let index = await partition(start, end);\n     // restore original state\n     states[index] = -1;\n     await Promise.all([quickSort(start, index - 1), quickSort(index + 1, end)]);\n }\n // We have chosen the element at the last index as \n\n // the pivot element, but we could've made different\n\n // choices, e.g. take the first element as pivot.\n async function partition(start, end) {\n     for (let i = start; i < end; i++) {\n         // identify the elements being considered currently\n         states[i] = 1;\n     }\n     // Quicksort algorithm\n     let pivotIndex = start;\n     // make pivot index distinct\n     states[pivotIndex] = 0;\n     let pivotElement = values[end];\n     for (let i = start; i < end; i++) {\n         if (values[i] < pivotElement) {\n             await swap(i, pivotIndex);\n             states[pivotIndex] = -1;\n             pivotIndex++;\n             states[pivotIndex] = 0;\n         }\n     }\n     await swap(end, pivotIndex);\n     for (let i = start; i < end; i++) {\n         // restore original state\n         if (i != pivotIndex) {\n             states[i] = -1;\n         }\n     }\n     return pivotIndex;\n }\n // swaps elements of 'values' at indices 'i' and 'j'\n async function swap(i, j) {\n     // adjust the pace of the simulation by changing the\n\n     // value\n     await sleep(25);\n     let temp = values[i];\n     values[i] = values[j];\n     values[j] = temp;\n }\n // custom helper function to deliberately slow down\n\n // the sorting process and make visualization easy\n function sleep(ms) {\n     return new Promise(resolve => setTimeout(resolve, ms));\n }"
            }
        ]
    },
    {
        "groupName": "Interaction",
        "examples": [
            {
                "name": "Tickle",
                "description": "The word \"tickle\" jitters when the cursor hovers over. Sometimes, it can be tickled off the screen.",
                "code": " let message = 'tickle',\n     font, bounds,\n     // holds x, y, w, h of the text's bounding box\n     fontsize = 60,\n     x, y;\n // x and y coordinates of the text\n function preload() {\n     font = loadFont('assets/SourceSansPro-Regular.otf');\n }\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     // set up the font\n     textFont(font);\n     textSize(fontsize);\n     // get the width and height of the text so we can center it initially\n     bounds = font.textBounds(message, 0, 0, fontsize);\n     x = width / 2 - bounds.w / 2;\n     y = height / 2 - bounds.h / 2;\n }\n\n function draw() {\n     background(204, 120);\n     // write the text in black and get its bounding box\n     fill(0);\n     text(message, x, y);\n     bounds = font.textBounds(message, x, y, fontsize);\n     // check if the mouse is inside the bounding box and tickle if so\n     if (mouseX >= bounds.x && mouseX <= bounds.x + bounds.w && mouseY >= bounds.y && mouseY <= bounds.y + bounds.h) {\n         x += random(-5, 5);\n         y += random(-5, 5);\n     }\n }"
            },
            {
                "name": "Weight Line",
                "description": "contributed by Prof WM Harris, using the random function with events to color/weight a line\nHow to use the random function with events to color/ weight a line dependent on mouse location, left mouse button clicks, character key types, and random key releases.\nFunctions are created for both the canvas set up as well as the creation of the line. Depending on the action taken by the user the line can vary in width and color. Left mouse button clicks result in a color change to blue, while the typing of any character key will change the color to turquoise, each resulting in a variable stroke weight; the width of the former will be between 0 – 1 while the width of the latter will be 0 – 5. The release of any key will result in a random hue, saturation, and brightness change to the line.",
                "code": " function setup() {\n     createCanvas(screenWidth, screenHeight);\n     background(\"beige\");\n     colorMode(HSB);\n }\n\n function draw() {\n     //Line from prev pt to current pt\n\n     //of mouse position\n     line(mouseX, mouseY, pmouseX, pmouseY);\n }\n //listen when we click the mouse\n function mouseClicked() {\n     //weights 0 to 1\n     stroke(\"slateBlue\");\n     strokeWeight(random());\n     //what if want weights 0 to .4?\n\n     //strokeWeight( random(.4) );\n }\n //listen when we release *any* key\n function keyReleased() {\n     //color hue values between 20 and 145\n\n     //saturation 0 to 100\n\n     //brightness 80 to 100\n     stroke(random(20, 145), random(100), random(80, 100));\n }\n //listen for only character keys\n function keyTyped() {\n     //weights 0 to 5\n     stroke(\"turquoise\");\n     strokeWeight(random(5));\n }"
            },
            {
                "name": "Follow 1",
                "description": "A line segment is pushed and pulled by the cursor. Based on code from Keith Peters.",
                "code": ""
            },
            {
                "name": "Follow 2",
                "description": "A two-segmented arm follows the cursor position. The relative angle between the segments is calculated with atan2() and the position calculated with sin() and cos(). Based on code from Keith Peters.",
                "code": " let x = [0, 0],\n     y = [0, 0],\n     segLength = 50;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     strokeWeight(20.0);\n     stroke(255, 100);\n }\n\n function draw() {\n     background(0);\n     dragSegment(0, mouseX, mouseY);\n     dragSegment(1, x[0], y[0]);\n }\n\n function dragSegment(i, xin, yin) {\n     const dx = xin - x[i];\n     const dy = yin - y[i];\n     const angle = atan2(dy, dx);\n     x[i] = xin - cos(angle) * segLength;\n     y[i] = yin - sin(angle) * segLength;\n     segment(x[i], y[i], angle);\n }\n\n function segment(x, y, a) {\n     push();\n     translate(x, y);\n     rotate(a);\n     line(0, 0, segLength, 0);\n     pop();\n }"
            },
            {
                "name": "Follow 3",
                "description": "A segmented line follows the mouse. The relative angle from each segment to the next is calculated with atan2() and the position of the next is calculated with sin() and cos(). Based on code from Keith Peters.",
                "code": " let x = [],\n     y = [],\n     segNum = 20,\n     segLength = 18;\n for (let i = 0; i < segNum; i++) {\n     x[i] = 0;\n     y[i] = 0;\n }\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     strokeWeight(9);\n     stroke(255, 100);\n }\n\n function draw() {\n     background(0);\n     dragSegment(0, mouseX, mouseY);\n     for (let i = 0; i < x.length - 1; i++) {\n         dragSegment(i + 1, x[i], y[i]);\n     }\n }\n\n function dragSegment(i, xin, yin) {\n     const dx = xin - x[i];\n     const dy = yin - y[i];\n     const angle = atan2(dy, dx);\n     x[i] = xin - cos(angle) * segLength;\n     y[i] = yin - sin(angle) * segLength;\n     segment(x[i], y[i], angle);\n }\n\n function segment(x, y, a) {\n     push();\n     translate(x, y);\n     rotate(a);\n     line(0, 0, segLength, 0);\n     pop();\n }"
            },
            {
                "name": "Snake game",
                "description": "The famous snake game! Once you click run, click anywhere inside the black area, and control the snake using i j k and l. Don't let the snake hit itself or the wall!\nExample created by Prashant Gupta",
                "code": " // the snake is divided into small segments, which are drawn and edited on each 'draw' call\n let numSegments = 10;\n let direction = 'right';\n const xStart = 0;\n //starting x coordinate for snake\n const yStart = 250;\n //starting y coordinate for snake\n const diff = 10;\n let xCor = [];\n let yCor = [];\n let xFruit = 0;\n let yFruit = 0;\n let scoreElem;\n\n function setup() {\n     scoreElem = createDiv('Score = 0');\n     scoreElem.position(20, 20);\n     scoreElem.id = 'score';\n     scoreElem.style('color', 'white');\n     createCanvas(screenWidth, screenHeight);\n     frameRate(15);\n     stroke(255);\n     strokeWeight(10);\n     updateFruitCoordinates();\n     for (let i = 0; i < numSegments; i++) {\n         xCor.push(xStart + i * diff);\n         yCor.push(yStart);\n     }\n }\n\n function draw() {\n     background(0);\n     for (let i = 0; i < numSegments - 1; i++) {\n         line(xCor[i], yCor[i], xCor[i + 1], yCor[i + 1]);\n     }\n     updateSnakeCoordinates();\n     checkGameStatus();\n     checkForFruit();\n }\n /*\n  \n  The segments are updated based on the direction of the snake.\n  \n  All segments from 0 to n-1 are just copied over to 1 till n, i.e. segment 0\n  \n  gets the value of segment 1, segment 1 gets the value of segment 2, and so on,\n  \n  and this results in the movement of the snake.\n  \n  The last segment is added based on the direction in which the snake is going,\n  \n  if it's going left or right, the last segment's x coordinate is increased by a\n  \n  predefined value 'diff' than its second to last segment. And if it's going up\n  \n  or down, the segment's y coordinate is affected.\n  \n */\n function updateSnakeCoordinates() {\n     for (let i = 0; i < numSegments - 1; i++) {\n         xCor[i] = xCor[i + 1];\n         yCor[i] = yCor[i + 1];\n     }\n     switch (direction) {\n         case 'right':\n             xCor[numSegments - 1] = xCor[numSegments - 2] + diff;\n             yCor[numSegments - 1] = yCor[numSegments - 2];\n             break;\n         case 'up':\n             xCor[numSegments - 1] = xCor[numSegments - 2];\n             yCor[numSegments - 1] = yCor[numSegments - 2] - diff;\n             break;\n         case 'left':\n             xCor[numSegments - 1] = xCor[numSegments - 2] - diff;\n             yCor[numSegments - 1] = yCor[numSegments - 2];\n             break;\n         case 'down':\n             xCor[numSegments - 1] = xCor[numSegments - 2];\n             yCor[numSegments - 1] = yCor[numSegments - 2] + diff;\n             break;\n     }\n }\n /*\n  \n  I always check the snake's head position xCor[xCor.length - 1] and\n  \n  yCor[yCor.length - 1] to see if it touches the game's boundaries\n  \n  or if the snake hits itself.\n  \n */\n function checkGameStatus() {\n     if (xCor[xCor.length - 1] > width || xCor[xCor.length - 1] < 0 || yCor[yCor.length - 1] > height || yCor[yCor.length - 1] < 0 || checkSnakeCollision()) {\n         noLoop();\n         const scoreVal = parseInt(scoreElem.html().substring(8));\n         scoreElem.html('Game ended! Your score was : ' + scoreVal);\n     }\n }\n /*\n  \n  If the snake hits itself, that means the snake head's (x,y) coordinate\n  \n  has to be the same as one of its own segment's (x,y) coordinate.\n  \n */\n function checkSnakeCollision() {\n     const snakeHeadX = xCor[xCor.length - 1];\n     const snakeHeadY = yCor[yCor.length - 1];\n     for (let i = 0; i < xCor.length - 1; i++) {\n         if (xCor[i] === snakeHeadX && yCor[i] === snakeHeadY) {\n             return true;\n         }\n     }\n }\n /*\n  \n  Whenever the snake consumes a fruit, I increment the number of segments,\n  \n  and just insert the tail segment again at the start of the array (basically\n  \n  I add the last segment again at the tail, thereby extending the tail)\n  \n */\n function checkForFruit() {\n     point(xFruit, yFruit);\n     if (xCor[xCor.length - 1] === xFruit && yCor[yCor.length - 1] === yFruit) {\n         const prevScore = parseInt(scoreElem.html().substring(8));\n         scoreElem.html('Score = ' + (prevScore + 1));\n         xCor.unshift(xCor[0]);\n         yCor.unshift(yCor[0]);\n         numSegments++;\n         updateFruitCoordinates();\n     }\n }\n\n function updateFruitCoordinates() {\n     /*\n         \n       The complex math logic is because I wanted the point to lie\n         \n       in between 100 and width-100, and be rounded off to the nearest\n         \n       number divisible by 10, since I move the snake in multiples of 10.\n      \n       */\n     xFruit = floor(random(10, (width - 100) / 10)) * 10;\n     yFruit = floor(random(10, (height - 100) / 10)) * 10;\n }\n\n function keyPressed() {\n     switch (keyCode) {\n         case 74:\n             if (direction !== 'right') {\n                 direction = 'left';\n             }\n             break;\n         case 76:\n             if (direction !== 'left') {\n                 direction = 'right';\n             }\n             break;\n         case 73:\n             if (direction !== 'down') {\n                 direction = 'up';\n             }\n             break;\n         case 75:\n             if (direction !== 'up') {\n                 direction = 'down';\n             }\n             break;\n     }\n }"
            },
            {
                "name": "Wavemaker",
                "description": "This illustrates how waves (like water waves) emerge from particles oscillating in place. Move your mouse to direct the wave. Contributed by Aatish Bhatia, inspired by Orbiters by Dave Whyte.",
                "code": " let t = 0;\n // time variable\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     noStroke();\n     fill(40, 200, 40);\n }\n\n function draw() {\n     background(10, 10);\n     // translucent background (creates trails)\n\n     // make a x and y grid of ellipses\n     for (let x = 0; x <= width; x = x + 30) {\n         for (let y = 0; y <= height; y = y + 30) {\n             // starting point of each circle depends on mouse position\n             const xAngle = map(mouseX, 0, width, -4 * PI, 4 * PI, true);\n             const yAngle = map(mouseY, 0, height, -4 * PI, 4 * PI, true);\n             // and also varies based on the particle's location\n             const angle = xAngle * (x / width) + yAngle * (y / height);\n             // each particle moves in a circle\n             const myX = x + 20 * cos(2 * PI * t + angle);\n             const myY = y + 20 * sin(2 * PI * t + angle);\n             ellipse(myX, myY, 10);\n             // draw particle\n         }\n     }\n     t = t + 0.01;\n     // update time\n }"
            },
            {
                "name": "Reach 1",
                "description": "The arm follows the position of the mouse by calculating the angles with atan2(). Based on code from Keith Peters.",
                "code": " let segLength = 80,\n     x, y, x2, y2;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     strokeWeight(20);\n     stroke(255, 100);\n     x = width / 2;\n     y = height / 2;\n     x2 = x;\n     y2 = y;\n }\n\n function draw() {\n     background(0);\n     dragSegment(0, mouseX, mouseY);\n     for (let i = 0; i < x.length - 1; i++) {\n         dragSegment(i + 1, x[i], y[i]);\n     }\n }\n\n function dragSegment(i, xin, yin) {\n     background(0);\n     dx = mouseX - x;\n     dy = mouseY - y;\n     angle1 = atan2(dy, dx);\n     tx = mouseX - cos(angle1) * segLength;\n     ty = mouseY - sin(angle1) * segLength;\n     dx = tx - x2;\n     dy = ty - y2;\n     angle2 = atan2(dy, dx);\n     x = x2 + cos(angle2) * segLength;\n     y = y2 + sin(angle2) * segLength;\n     segment(x, y, angle1);\n     segment(x2, y2, angle2);\n }\n\n function segment(x, y, a) {\n     push();\n     translate(x, y);\n     rotate(a);\n     line(0, 0, segLength, 0);\n     pop();\n }"
            },
            {
                "name": "Reach 2",
                "description": "The arm follows the position of the mouse by calculating the angles with atan2(). Based on code from Keith Peters.",
                "code": " let numSegments = 10,\n     x = [],\n     y = [],\n     angle = [],\n     segLength = 26,\n     targetX, targetY;\n for (let i = 0; i < numSegments; i++) {\n     x[i] = 0;\n     y[i] = 0;\n     angle[i] = 0;\n }\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     strokeWeight(20);\n     stroke(255, 100);\n     x[x.length - 1] = width / 2;\n     // Set base x-coordinate\n     y[x.length - 1] = height;\n     // Set base y-coordinate\n }\n\n function draw() {\n     background(0);\n     reachSegment(0, mouseX, mouseY);\n     for (let i = 1; i < numSegments; i++) {\n         reachSegment(i, targetX, targetY);\n     }\n     for (let j = x.length - 1; j >= 1; j--) {\n         positionSegment(j, j - 1);\n     }\n     for (let k = 0; k < x.length; k++) {\n         segment(x[k], y[k], angle[k], (k + 1) * 2);\n     }\n }\n\n function positionSegment(a, b) {\n     x[b] = x[a] + cos(angle[a]) * segLength;\n     y[b] = y[a] + sin(angle[a]) * segLength;\n }\n\n function reachSegment(i, xin, yin) {\n     const dx = xin - x[i];\n     const dy = yin - y[i];\n     angle[i] = atan2(dy, dx);\n     targetX = xin - cos(angle[i]) * segLength;\n     targetY = yin - sin(angle[i]) * segLength;\n }\n\n function segment(x, y, a, sw) {\n     strokeWeight(sw);\n     push();\n     translate(x, y);\n     rotate(a);\n     line(0, 0, segLength, 0);\n     pop();\n }"
            },
            {
                "name": "Reach 3",
                "description": "The arm follows the position of the ball by calculating the angles with atan2(). Based on code from Keith Peters.",
                "code": " let numSegments = 8,\n     x = [],\n     y = [],\n     angle = [],\n     segLength = 26,\n     targetX, targetY, ballX = 50,\n     ballY = 50,\n     ballXDirection = 1,\n     ballYDirection = -1;\n for (let i = 0; i < numSegments; i++) {\n     x[i] = 0;\n     y[i] = 0;\n     angle[i] = 0;\n }\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     strokeWeight(20);\n     stroke(255, 100);\n     noFill();\n     x[x.length - 1] = width / 2;\n     // Set base x-coordinate\n     y[x.length - 1] = height;\n     // Set base y-coordinate\n }\n\n function draw() {\n     background(0);\n     strokeWeight(20);\n     ballX = ballX + 1.0 * ballXDirection;\n     ballY = ballY + 0.8 * ballYDirection;\n     if (ballX > width - 25 || ballX < 25) {\n         ballXDirection *= -1;\n     }\n     if (ballY > height - 25 || ballY < 25) {\n         ballYDirection *= -1;\n     }\n     ellipse(ballX, ballY, 30, 30);\n     reachSegment(0, ballX, ballY);\n     for (let i = 1; i < numSegments; i++) {\n         reachSegment(i, targetX, targetY);\n     }\n     for (let j = x.length - 1; j >= 1; j--) {\n         positionSegment(j, j - 1);\n     }\n     for (let k = 0; k < x.length; k++) {\n         segment(x[k], y[k], angle[k], (k + 1) * 2);\n     }\n }\n\n function positionSegment(a, b) {\n     x[b] = x[a] + cos(angle[a]) * segLength;\n     y[b] = y[a] + sin(angle[a]) * segLength;\n }\n\n function reachSegment(i, xin, yin) {\n     const dx = xin - x[i];\n     const dy = yin - y[i];\n     angle[i] = atan2(dy, dx);\n     targetX = xin - cos(angle[i]) * segLength;\n     targetY = yin - sin(angle[i]) * segLength;\n }\n\n function segment(x, y, a, sw) {\n     strokeWeight(sw);\n     push();\n     translate(x, y);\n     rotate(a);\n     line(0, 0, segLength, 0);\n     pop();\n }"
            },
            {
                "name": "Arduino sensor data via WebJack",
                "description": "WebJack is a way to read data from an Arduino (and other sources) using audio -- it basically turns your Arduino into an audio modem. https://github.com/publiclab/webjack Note: WebJack and p5-webjack libraries must be added to your index.html as follows:\n<script src=\"https://webjack.io/dist/webjack.js\"></script>\n<script src=\"https://jywarren.github.io/p5-webjack/lib.js\"></script>\nWorking example: https://editor.p5js.org/jywarren/sketches/rkztwSt8M Testing audio: https://www.youtube.com/watch?v=GtJW1Dlt3cg Load this sketch onto an Arduino: https://create.arduino.cc/editor/jywarren/023158d8-be51-4c78-99ff-36c63126b554/preview Arduino will output audio from pin 3 + ground. Use microphone or an audio cable.",
                "code": " function setup() {\n     createCanvas(screenWidth, screenHeight);\n     noStroke();\n     fill('#ff00aa22');\n     receiveSensorData(handleData);\n }\n\n function handleData(data, connection) {\n     console.log(data);\n     // output the values to log\n\n     // data[0] is the 1st value, data[1] 2nd, etc.\n\n     // draw stuff! Browse http://p5js.org/reference/\n     background('#ddd');\n     ellipse(100, 200, data[0] + 10, data[0] + 10);\n     // connection.send('send data back to the Arduino if its listening');\n }"
            },
            {
                "name": "Kaleidoscope",
                "description": "A kaleidoscope is an optical instrument with two or more reflecting surfaces tilted to each other in an angle. This example tries to replicate the behavior of a kaleidoscope. Set the number of reflections at the symmetry variable and start drawing on the screen. Adjust the brush size with the help of the slider. The clear screen as it says clears the screen. The save button will download a .jpg file of the art that you have created.",
                "code": " // Symmetry corresponding to the number of reflections. Change the number for different number of reflections \n let symmetry = 6;\n let angle = 360 / symmetry;\n let saveButton, clearButton, mouseButton, keyboardButton;\n let slider;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     angleMode(DEGREES);\n     background(127);\n     // Creating the save button for the file\n     saveButton = createButton('save');\n     saveButton.mousePressed(saveFile);\n     // Creating the clear screen button\n     clearButton = createButton('clear');\n     clearButton.mousePressed(clearScreen);\n     // Creating the button for Full Screen\n     fullscreenButton = createButton('Full Screen');\n     fullscreenButton.mousePressed(screenFull);\n     // Setting up the slider for the thickness of the brush\n     brushSizeSlider = createButton('Brush Size Slider');\n     sizeSlider = createSlider(1, 32, 4, 0.1);\n }\n // Save File Function\n function saveFile() {\n     save('design.jpg');\n }\n // Clear Screen function\n function clearScreen() {\n     background(127);\n }\n // Full Screen Function\n function screenFull() {\n     let fs = fullscreen();\n     fullscreen(!fs);\n }\n\n function draw() {\n     translate(width / 2, height / 2);\n     if (mouseX > 0 && mouseX < width && mouseY > 0 && mouseY < height) {\n         let mx = mouseX - width / 2;\n         let my = mouseY - height / 2;\n         let pmx = pmouseX - width / 2;\n         let pmy = pmouseY - height / 2;\n         if (mouseIsPressed) {\n             for (let i = 0; i < symmetry; i++) {\n                 rotate(angle);\n                 let sw = sizeSlider.value();\n                 strokeWeight(sw);\n                 line(mx, my, pmx, pmy);\n                 push();\n                 scale(1, -1);\n                 line(mx, my, pmx, pmy);\n                 pop();\n             }\n         }\n     }\n }"
            }
        ]
    },
    {
        "groupName": "Objects",
        "examples": [
            {
                "name": "Objects",
                "description": "Create a Jitter class, instantiate an object, and move it around the screen. Adapted from Getting Started with Processing by Casey Reas and Ben Fry.",
                "code": ""
            },
            {
                "name": "Multiple Objects",
                "description": "Create a Jitter class, instantiate multiple objects, and move it around the screen.",
                "code": " let bug1;\n // Declare objects\n let bug2;\n let bug3;\n let bug4;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     // Create object\n     bug1 = new Jitter();\n     bug2 = new Jitter();\n     bug3 = new Jitter();\n     bug4 = new Jitter();\n }\n\n function draw() {\n     background(50, 89, 100);\n     bug1.move();\n     bug1.display();\n     bug2.move();\n     bug2.display();\n     bug3.move();\n     bug3.display();\n     bug4.move();\n     bug4.display();\n }\n // Jitter class\n class Jitter {\n     constructor() {\n         this.x = random(width);\n         this.y = random(height);\n         this.diameter = random(10, 30);\n         this.speed = 1;\n     }\n     move() {\n         this.x += random(-this.speed, this.speed);\n         this.y += random(-this.speed, this.speed);\n     }\n     display() {\n         ellipse(this.x, this.y, this.diameter, this.diameter);\n     }\n }"
            },
            {
                "name": "Array of Objects",
                "description": "Create a Jitter class, instantiate an array of objects and move them around the screen.",
                "code": " let bugs = [];\n // array of Jitter objects\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     // Create objects\n     for (let i = 0; i < 50; i++) {\n         bugs.push(new Jitter());\n     }\n }\n\n function draw() {\n     background(50, 89, 100);\n     for (let i = 0; i < bugs.length; i++) {\n         bugs[i].move();\n         bugs[i].display();\n     }\n }\n // Jitter class\n class Jitter {\n     constructor() {\n         this.x = random(width);\n         this.y = random(height);\n         this.diameter = random(10, 30);\n         this.speed = 1;\n     }\n     move() {\n         this.x += random(-this.speed, this.speed);\n         this.y += random(-this.speed, this.speed);\n     }\n     display() {\n         ellipse(this.x, this.y, this.diameter, this.diameter);\n     }\n }"
            },
            {
                "name": "Objects 2",
                "description": "Ported from example by hbarragan. Move the cursor across the image to change the speed and positions of the geometry. The class MRect defines a group of lines.",
                "code": " let r1, r2, r3, r4;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     fill(255, 204);\n     noStroke();\n     r1 = new MRect(1, 134.0, 0.532, 0.1 * height, 10.0, 60.0);\n     r2 = new MRect(2, 44.0, 0.166, 0.3 * height, 5.0, 50.0);\n     r3 = new MRect(2, 58.0, 0.332, 0.4 * height, 10.0, 35.0);\n     r4 = new MRect(1, 120.0, 0.0498, 0.9 * height, 15.0, 60.0);\n }\n\n function draw() {\n     background(0);\n     r1.display();\n     r2.display();\n     r3.display();\n     r4.display();\n     r1.move(mouseX - width / 2, mouseY + height * 0.1, 30);\n     r2.move((mouseX + width * 0.05) % width, mouseY + height * 0.025, 20);\n     r3.move(mouseX / 4, mouseY - height * 0.025, 40);\n     r4.move(mouseX - width / 2, height - mouseY, 50);\n }\n class MRect {\n     constructor(iw, ixp, ih, iyp, id, it) {\n         this.w = iw;\n         // single bar width\n         this.xpos = ixp;\n         // rect xposition\n         this.h = ih;\n         // rect height\n         this.ypos = iyp;\n         // rect yposition\n         this.d = id;\n         // single bar distance\n         this.t = it;\n         // number of bars\n     }\n     move(posX, posY, damping) {\n         let dif = this.ypos - posY;\n         if (abs(dif) > 1) {\n             this.ypos -= dif / damping;\n         }\n         dif = this.xpos - posX;\n         if (abs(dif) > 1) {\n             this.xpos -= dif / damping;\n         }\n     }\n     display() {\n         for (let i = 0; i < this.t; i++) {\n             rect(this.xpos + i * (this.d + this.w), this.ypos, this.w, height * this.h);\n         }\n     }\n }"
            },
            {
                "name": "Inheritance",
                "description": "A class can be defined using another class as a foundation. In object-oriented programming terminology, one class can inherit fields and methods from another. An object that inherits from another is called a subclass, and the object it inherits from is called a superclass. A subclass extends the superclass.",
                "code": " let spots, arm;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     arm = new SpinArm(width / 2, height / 2, 0.01);\n     spots = new SpinSpots(width / 2, height / 2, -0.02, 90.0);\n }\n\n function draw() {\n     background(204);\n     arm.update();\n     arm.display();\n     spots.update();\n     spots.display();\n }\n class Spin {\n     constructor(x, y, s) {\n         this.x = x;\n         this.y = y;\n         this.speed = s;\n         this.angle = 0.0;\n     }\n     update() {\n         this.angle += this.speed;\n     }\n }\n class SpinArm extends Spin {\n     constructor(x, y, s) {\n         super(x, y, s)\n     }\n     display() {\n         strokeWeight(1);\n         stroke(0);\n         push();\n         translate(this.x, this.y);\n         this.angle += this.speed;\n         rotate(this.angle);\n         line(0, 0, 165, 0);\n         pop();\n     }\n }\n class SpinSpots extends Spin {\n     constructor(x, y, s, d) {\n         super(x, y, s) this.dim = d;\n     }\n     display() {\n         noStroke();\n         push();\n         translate(this.x, this.y);\n         this.angle += this.speed;\n         rotate(this.angle);\n         ellipse(-this.dim / 2, 0, this.dim, this.dim);\n         ellipse(this.dim / 2, 0, this.dim, this.dim);\n         pop();\n     }\n }"
            },
            {
                "name": "Composite Objects",
                "description": "An object can include several other objects. Creating such composite objects is a good way to use the principles of modularity and build higher levels of abstraction within a program.",
                "code": " let er1, er2;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     er1 = new EggRing(width * 0.45, height * 0.5, 0.1, 120);\n     er2 = new EggRing(width * 0.65, height * 0.8, 0.05, 180);\n }\n\n function draw() {\n     background(0);\n     er1.transmit();\n     er2.transmit();\n }\n class Egg {\n     constructor(xpos, ypos, t, s) {\n         this.x = xpos;\n         this.y = ypos;\n         this.tilt = t;\n         this.scalar = s / 100.0;\n         this.angle = 0.0;\n     }\n     wobble() {\n         this.tilt = cos(this.angle) / 8;\n         this.angle += 0.1;\n     }\n     display() {\n         noStroke();\n         fill(255);\n         push();\n         translate(this.x, this.y);\n         rotate(this.tilt);\n         scale(this.scalar);\n         beginShape();\n         vertex(0, -100);\n         bezierVertex(25, -100, 40, -65, 40, -40);\n         bezierVertex(40, -15, 25, 0, 0, 0);\n         bezierVertex(-25, 0, -40, -15, -40, -40);\n         bezierVertex(-40, -65, -25, -100, 0, -100);\n         endShape();\n         pop();\n     }\n }\n class Ring {\n     start(xpos, ypos) {\n         this.x = xpos;\n         this.y = ypos;\n         this.on = true;\n         this.diameter = 1;\n     }\n     grow() {\n         if (this.on == true) {\n             this.diameter += 0.5;\n             if (this.diameter > width * 2) {\n                 this.diameter = 0.0;\n             }\n         }\n     }\n     display() {\n         if (this.on == true) {\n             noFill();\n             strokeWeight(4);\n             stroke(155, 153);\n             ellipse(this.x, this.y, this.diameter, this.diameter);\n         }\n     }\n }\n class EggRing {\n     constructor(x, y, t, sp) {\n         this.x = x;\n         this.y = y;\n         this.t = t;\n         this.sp = sp;\n         this.circle = new Ring();\n         this.ovoid = new Egg(this.x, this.y, this.t, this.sp);\n         this.circle.start(this.x, this.y - this.sp / 2);\n     }\n     transmit() {\n         this.ovoid.wobble();\n         this.ovoid.display();\n         this.circle.grow();\n         this.circle.display();\n         if (circle.on == false) {\n             circle.on = true;\n         }\n     }\n }"
            },
            {
                "name": "Car Instances",
                "description": "contributed by Prof WM Harris, How to create three instances of Car Class and invoke class methods.\nA function is created for the canvas setup, and 3 car instances are initialized with different colors and canvas positions. The speed of each car is set by passing value to the instance’s start method. A second function calls class methods to display and move the cars.",
                "code": " class Car {\n     /* Constructor expects parameters for\n      \n       fill color, x and y coordinates that\n      \n       will be used to initialize class properties.\n      \n       */\n     constructor(cColor, x, y) {\n         this.color = cColor;\n         this.doors = 4;\n         this.isConvertible = false;\n         this.x = x;\n         this.y = y;\n         this.speed = 0;\n     }\n     start(speed) {\n         // method expects parameter!\n         this.speed = speed;\n     }\n     display() {\n         // method!\n         fill(this.color);\n         rect(this.x, this.y, 20, 10);\n     }\n     move() {\n         // method!\n         this.x += this.speed;\n         // Wrap x around boundaries\n         if (this.x < -20) {\n             this.x = width;\n         } else if (this.x > width) {\n             this.x = -20;\n         }\n     }\n }\n //end class Car\n let rav4;\n let charger;\n let nova;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     /* Construct the 3 Cars */\n\n     //constructor expects cColor, x, y\n     rav4 = new Car(\"silver\", 100, 300);\n     charger = new Car(\"gold\", 0, 200);\n     nova = new Car(\"blue\", 200, 100);\n     nova.doors = 2;\n     //update nova's doors property\n     console.log(\"rav4\", rav4);\n     console.log(\"charger\", charger);\n     console.log(\"nova\", nova);\n     //call start methods of Car instances\n\n     //the start method expects a number for speed\n     rav4.start(2.3);\n     charger.start(-4);\n     nova.start(random(-1, 1));\n }\n\n function draw() {\n     background(\"beige\");\n     //display and move all 3 Cars\n     rav4.display();\n     charger.display();\n     nova.display();\n     rav4.move();\n     charger.move();\n     nova.move();\n }"
            }
        ]
    },
    {
        "groupName": "Lights",
        "examples": [
            {
                "name": "Directional",
                "description": "Move the mouse to change the direction of the light. Directional light comes from one direction and is stronger when hitting a surface squarely and weaker if it hits at a a gentle angle. After hitting a surface, a directional light scatters in all directions.",
                "code": ""
            },
            {
                "name": "Mixture",
                "description": "Display a box with three different kinds of lights.",
                "code": " function setup() {\n     createCanvas(screenWidth, screenHeight, WEBGL);\n     noStroke();\n }\n\n function draw() {\n     background(0);\n     // ambient light\n     ambientLight(0, 255 / 4, 0);\n     // to set the light position,\n\n     // think of the world's coordinate as:\n\n     // -width/2,-height/2 -------- width/2,-height/2\n\n     //                |            |\n\n     //                |     0,0    |\n\n     //                |            |\n\n     // -width/2,height/2--------width/2,height/2\n\n     // blue directional light from the left\n     directionalLight(0, 0, 255, -1, 0, 0);\n     // calculate distance from center to mouseX\n     let lightX = mouseX - width / 2;\n     let lightY = mouseY - height / 2;\n     // red spotlight\n\n     // axis located at lightX, lightY, 500\n\n     // axis direction of light: 0, 0, -1\n     spotLight(255, 0, 0, lightX, lightY, 500, 0, 0, -1);\n     // rotate on X axis\n     rotateX(-PI / 4);\n     // rotate on Y axis\n     rotateY(PI / 4);\n     // place box on (0, 0, 0), size 100\n     box(100);\n }"
            }
        ]
    },
    {
        "groupName": "Motion",
        "examples": [
            {
                "name": "Non Orthogonal Reflection",
                "description": "This is a port by David Blitz of the \"Reflection 1\" example from processing.org/examples",
                "code": " //Position of left hand side of floor\n let base1;\n //Position of right hand side of floor\n let base2;\n //Length of floor\n\n //let baseLength;\n\n // Variables related to moving ball\n let position;\n let velocity;\n let r = 6;\n let speed = 3.5;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     fill(128);\n     base1 = createVector(0, height - 150);\n     base2 = createVector(width, height);\n     //createGround();\n\n     //start ellipse at middle top of screen\n     position = createVector(width / 2, 0);\n     //calculate initial random velocity\n     velocity = p5.Vector.random2D();\n     velocity.mult(speed);\n }\n\n function draw() {\n     //draw background\n     fill(0, 12);\n     noStroke();\n     rect(0, 0, width, height);\n     //draw base\n     fill(200);\n     quad(base1.x, base1.y, base2.x, base2.y, base2.x, height, 0, height);\n     //calculate base top normal\n     let baseDelta = p5.Vector.sub(base2, base1);\n     baseDelta.normalize();\n     let normal = createVector(-baseDelta.y, baseDelta.x);\n     let intercept = p5.Vector.dot(base1, normal);\n     //draw ellipse\n     noStroke();\n     fill(255);\n     ellipse(position.x, position.y, r * 2, r * 2);\n     //move ellipse\n     position.add(velocity);\n     //normalized incidence vector\n     incidence = p5.Vector.mult(velocity, -1);\n     incidence.normalize();\n     // detect and handle collision with base\n     if (p5.Vector.dot(normal, position) > intercept) {\n         //calculate dot product of incident vector and base top\n         let dot = incidence.dot(normal);\n         //calculate reflection vector\n\n         //assign reflection vector to direction vector\n         velocity.set(2 * normal.x * dot - incidence.x, 2 * normal.y * dot - incidence.y, 0);\n         velocity.mult(speed);\n         // draw base top normal at collision point\n         stroke(255, 128, 0);\n         line(position.x, position.y, position.x - normal.x * 100, position.y - normal.y * 100);\n     }\n     //}\n\n     // detect boundary collision\n\n     // right\n     if (position.x > width - r) {\n         position.x = width - r;\n         velocity.x *= -1;\n     }\n     // left\n     if (position.x < r) {\n         position.x = r;\n         velocity.x *= -1;\n     }\n     // top\n     if (position.y < r) {\n         position.y = r;\n         velocity.y *= -1;\n         //randomize base top\n         base1.y = random(height - 100, height);\n         base2.y = random(height - 100, height);\n     }\n }"
            },
            {
                "name": "Linear",
                "description": "Changing a variable to create a moving line. When the line moves off the edge of the window, the variable is set to 0, which places the line back at the bottom of the screen.",
                "code": " let a;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     stroke(255);\n     a = height / 2;\n }\n\n function draw() {\n     background(51);\n     line(0, a, width, a);\n     a = a - 0.5;\n     if (a < 0) {\n         a = height;\n     }\n }"
            },
            {
                "name": "Bounce",
                "description": "When the shape hits the edge of the window, it reverses its direction.",
                "code": " let rad = 60;\n // Width of the shape\n let xpos, ypos;\n // Starting position of shape\n let xspeed = 2.8;\n // Speed of the shape\n let yspeed = 2.2;\n // Speed of the shape\n let xdirection = 1;\n // Left or Right\n let ydirection = 1;\n // Top to Bottom\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     noStroke();\n     frameRate(30);\n     ellipseMode(RADIUS);\n     // Set the starting position of the shape\n     xpos = width / 2;\n     ypos = height / 2;\n }\n\n function draw() {\n     background(102);\n     // Update the position of the shape\n     xpos = xpos + xspeed * xdirection;\n     ypos = ypos + yspeed * ydirection;\n     // Test to see if the shape exceeds the boundaries of the screen\n\n     // If it does, reverse its direction by multiplying by -1\n     if (xpos > width - rad || xpos < rad) {\n         xdirection *= -1;\n     }\n     if (ypos > height - rad || ypos < rad) {\n         ydirection *= -1;\n     }\n     // Draw the shape\n     ellipse(xpos, ypos, rad, rad);\n }"
            },
            {
                "name": "Bouncy Bubbles",
                "description": "based on code from Keith Peters. Multiple-object collision..",
                "code": " let numBalls = 13;\n let spring = 0.05;\n let gravity = 0.03;\n let friction = -0.9;\n let balls = [];\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     for (let i = 0; i < numBalls; i++) {\n         balls[i] = new Ball(random(width), random(height), random(30, 70), i, balls);\n     }\n     noStroke();\n     fill(255, 204);\n }\n\n function draw() {\n     background(0);\n     balls.forEach(ball => {\n         ball.collide();\n         ball.move();\n         ball.display();\n     });\n }\n class Ball {\n     constructor(xin, yin, din, idin, oin) {\n         this.x = xin;\n         this.y = yin;\n         this.vx = 0;\n         this.vy = 0;\n         this.diameter = din;\n         this.id = idin;\n         this.others = oin;\n     }\n     collide() {\n         for (let i = this.id + 1; i < numBalls; i++) {\n             // console.log(others[i]);\n             let dx = this.others[i].x - this.x;\n             let dy = this.others[i].y - this.y;\n             let distance = sqrt(dx * dx + dy * dy);\n             let minDist = this.others[i].diameter / 2 + this.diameter / 2;\n             //   console.log(distance);\n\n             //console.log(minDist);\n             if (distance < minDist) {\n                 //console.log(\"2\");\n                 let angle = atan2(dy, dx);\n                 let targetX = this.x + cos(angle) * minDist;\n                 let targetY = this.y + sin(angle) * minDist;\n                 let ax = (targetX - this.others[i].x) * spring;\n                 let ay = (targetY - this.others[i].y) * spring;\n                 this.vx -= ax;\n                 this.vy -= ay;\n                 this.others[i].vx += ax;\n                 this.others[i].vy += ay;\n             }\n         }\n     }\n     move() {\n         this.vy += gravity;\n         this.x += this.vx;\n         this.y += this.vy;\n         if (this.x + this.diameter / 2 > width) {\n             this.x = width - this.diameter / 2;\n             this.vx *= friction;\n         } else if (this.x - this.diameter / 2 < 0) {\n             this.x = this.diameter / 2;\n             this.vx *= friction;\n         }\n         if (this.y + this.diameter / 2 > height) {\n             this.y = height - this.diameter / 2;\n             this.vy *= friction;\n         } else if (this.y - this.diameter / 2 < 0) {\n             this.y = this.diameter / 2;\n             this.vy *= friction;\n         }\n     }\n     display() {\n         ellipse(this.x, this.y, this.diameter, this.diameter);\n     }\n }"
            },
            {
                "name": "Morph",
                "description": "Changing one shape into another by interpolating vertices from one to another.",
                "code": " // Two ArrayLists to store the vertices for two shapes\n\n // This example assumes that each shape will have the same\n\n // number of vertices, i.e. the size of each ArrayList will be the same\n let circle = [];\n let square = [];\n // An ArrayList for a third set of vertices, the ones we will be drawing\n\n // in the window\n let morph = [];\n // This boolean variable will control if we are morphing to a circle or square\n let state = false;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     // Create a circle using vectors pointing from center\n     for (let angle = 0; angle < 360; angle += 9) {\n         // Note we are not starting from 0 in order to match the\n\n         // path of a circle.\n         let v = p5.Vector.fromAngle(radians(angle - 135));\n         v.mult(100);\n         circle.push(v);\n         // Let's fill out morph ArrayList with blank PVectors while we are at it\n         morph.push(createVector());\n     }\n     // A square is a bunch of vertices along straight lines\n\n     // Top of square\n     for (let x = -50; x < 50; x += 10) {\n         square.push(createVector(x, -50));\n     }\n     // Right side\n     for (let y = -50; y < 50; y += 10) {\n         square.push(createVector(50, y));\n     }\n     // Bottom\n     for (let x = 50; x > -50; x -= 10) {\n         square.push(createVector(x, 50));\n     }\n     // Left side\n     for (let y = 50; y > -50; y -= 10) {\n         square.push(createVector(-50, y));\n     }\n }\n\n function draw() {\n     background(51);\n     // We will keep how far the vertices are from their target\n     let totalDistance = 0;\n     // Look at each vertex\n     for (let i = 0; i < circle.length; i++) {\n         let v1;\n         // Are we lerping to the circle or square?\n         if (state) {\n             v1 = circle[i];\n         } else {\n             v1 = square[i];\n         }\n         // Get the vertex we will draw\n         let v2 = morph[i];\n         // Lerp to the target\n         v2.lerp(v1, 0.1);\n         // Check how far we are from target\n         totalDistance += p5.Vector.dist(v1, v2);\n     }\n     // If all the vertices are close, switch shape\n     if (totalDistance < 0.1) {\n         state = !state;\n     }\n     // Draw relative to center\n     translate(width / 2, height / 2);\n     strokeWeight(4);\n     // Draw a polygon that makes up all the vertices\n     beginShape();\n     noFill();\n     stroke(255);\n     morph.forEach(v => {\n         vertex(v.x, v.y);\n     });\n     endShape(CLOSE);\n }"
            },
            {
                "name": "Moving On Curves",
                "description": "In this example, the circles moves along the curve y = x^4. Click the mouse to have it move to a new position.",
                "code": " let beginX = 20.0;\n // Initial x-coordinate\n let beginY = 10.0;\n // Initial y-coordinate\n let endX = 570.0;\n // Final x-coordinate\n let endY = 320.0;\n // Final y-coordinate\n let distX;\n // X-axis distance to move\n let distY;\n // Y-axis distance to move\n let exponent = 4;\n // Determines the curve\n let x = 0.0;\n // Current x-coordinate\n let y = 0.0;\n // Current y-coordinate\n let step = 0.01;\n // Size of each step along the path\n let pct = 0.0;\n // Percentage traveled (0.0 to 1.0)\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     noStroke();\n     distX = endX - beginX;\n     distY = endY - beginY;\n }\n\n function draw() {\n     fill(0, 2);\n     rect(0, 0, width, height);\n     pct += step;\n     if (pct < 1.0) {\n         x = beginX + pct * distX;\n         y = beginY + pow(pct, exponent) * distY;\n     }\n     fill(255);\n     ellipse(x, y, 20, 20);\n }\n\n function mousePressed() {\n     pct = 0.0;\n     beginX = x;\n     beginY = y;\n     endX = mouseX;\n     endY = mouseY;\n     distX = endX - beginX;\n     distY = endY - beginY;\n }"
            },
            {
                "name": "Circle Collision",
                "description": "This is a port of the \"Circle Collision\" example from processing.org/examples\nThis example uses vectors for better visualization of physical Quantity",
                "code": " class Ball {\n     constructor(x, y, r) {\n         this.position = new p5.Vector(x, y);\n         this.velocity = p5.Vector.random2D();\n         this.velocity.mult(3);\n         this.r = r;\n         this.m = r * 0.1;\n     }\n     update() {\n         this.position.add(this.velocity);\n     }\n     checkBoundaryCollision() {\n         if (this.position.x > width - this.r) {\n             this.position.x = width - this.r;\n             this.velocity.x *= -1;\n         } else if (this.position.x < this.r) {\n             this.position.x = this.r;\n             this.velocity.x *= -1;\n         } else if (this.position.y > height - this.r) {\n             this.position.y = height - this.r;\n             this.velocity.y *= -1;\n         } else if (this.position.y < this.r) {\n             this.position.y = this.r;\n             this.velocity.y *= -1;\n         }\n     }\n     checkCollision(other) {\n         // Get distances between the balls components\n         let distanceVect = p5.Vector.sub(other.position, this.position);\n         // Calculate magnitude of the vector separating the balls\n         let distanceVectMag = distanceVect.mag();\n         // Minimum distance before they are touching\n         let minDistance = this.r + other.r;\n         if (distanceVectMag < minDistance) {\n             let distanceCorrection = (minDistance - distanceVectMag) / 2.0;\n             let d = distanceVect.copy();\n             let correctionVector = d.normalize().mult(distanceCorrection);\n             other.position.add(correctionVector);\n             this.position.sub(correctionVector);\n             // get angle of distanceVect\n             let theta = distanceVect.heading();\n             // precalculate trig values\n             let sine = sin(theta);\n             let cosine = cos(theta);\n             /* bTemp will hold rotated ball this.positions. You \n                       \n              just need to worry about bTemp[1] this.position*/\n             let bTemp = [new p5.Vector(), new p5.Vector()];\n             /* this ball's this.position is relative to the other\n                       \n              so you can use the vector between them (bVect) as the \n                       \n              reference point in the rotation expressions.\n                       \n              bTemp[0].this.position.x and bTemp[0].this.position.y will initialize\n                       \n              automatically to 0.0, which is what you want\n                       \n              since b[1] will rotate around b[0] */\n             bTemp[1].x = cosine * distanceVect.x + sine * distanceVect.y;\n             bTemp[1].y = cosine * distanceVect.y - sine * distanceVect.x;\n             // rotate Temporary velocities\n             let vTemp = [new p5.Vector(), new p5.Vector()];\n             vTemp[0].x = cosine * this.velocity.x + sine * this.velocity.y;\n             vTemp[0].y = cosine * this.velocity.y - sine * this.velocity.x;\n             vTemp[1].x = cosine * other.velocity.x + sine * other.velocity.y;\n             vTemp[1].y = cosine * other.velocity.y - sine * other.velocity.x;\n             /* Now that velocities are rotated, you can use 1D\n                       \n              conservation of momentum equations to calculate \n                       \n              the final this.velocity along the x-axis. */\n             let vFinal = [new p5.Vector(), new p5.Vector()];\n             // final rotated this.velocity for b[0]\n             vFinal[0].x = ((this.m - other.m) * vTemp[0].x + 2 * other.m * vTemp[1].x) / (this.m + other.m);\n             vFinal[0].y = vTemp[0].y;\n             // final rotated this.velocity for b[0]\n             vFinal[1].x = ((other.m - this.m) * vTemp[1].x + 2 * this.m * vTemp[0].x) / (this.m + other.m);\n             vFinal[1].y = vTemp[1].y;\n             // hack to avoid clumping\n             bTemp[0].x += vFinal[0].x;\n             bTemp[1].x += vFinal[1].x;\n             /* Rotate ball this.positions and velocities back\n                       \n              Reverse signs in trig expressions to rotate \n                       \n              in the opposite direction */\n\n             // rotate balls\n             let bFinal = [new p5.Vector(), new p5.Vector()];\n             bFinal[0].x = cosine * bTemp[0].x - sine * bTemp[0].y;\n             bFinal[0].y = cosine * bTemp[0].y + sine * bTemp[0].x;\n             bFinal[1].x = cosine * bTemp[1].x - sine * bTemp[1].y;\n             bFinal[1].y = cosine * bTemp[1].y + sine * bTemp[1].x;\n             // update balls to screen this.position\n             other.position.x = this.position.x + bFinal[1].x;\n             other.position.y = this.position.y + bFinal[1].y;\n             this.position.add(bFinal[0]);\n             // update velocities\n             this.velocity.x = cosine * vFinal[0].x - sine * vFinal[0].y;\n             this.velocity.y = cosine * vFinal[0].y + sine * vFinal[0].x;\n             other.velocity.x = cosine * vFinal[1].x - sine * vFinal[1].y;\n             other.velocity.y = cosine * vFinal[1].y + sine * vFinal[1].x;\n         }\n     }\n     display() {\n         noStroke();\n         fill(204);\n         ellipse(this.position.x, this.position.y, this.r * 2, this.r * 2);\n     }\n }\n let balls = [new Ball(100, 400, 20), new Ball(700, 400, 80)];\n console.log(balls);\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n }\n\n function draw() {\n     background(51);\n     for (let i = 0; i < balls.length; i++) {\n         let b = balls[i];\n         b.update();\n         b.display();\n         b.checkBoundaryCollision();\n         balls[0].checkCollision(balls[1]);\n     }\n }"
            }
        ]
    },
    {
        "groupName": "Instance Mode",
        "examples": [
            {
                "name": "Instantiation",
                "description": "Create a p5 instance, which keeps all variables out of the global scope of your page.",
                "code": " let sketch = function(p) {\n     let x = 100;\n     let y = 100;\n     p.setup = function() {\n         p.createCanvas(screenWidth, screenHeight);\n     };\n     p.draw = function() {\n         p.background(0);\n         p.fill(255);\n         p.rect(x, y, 50, 50);\n     };\n };\n let myp5 = new p5(sketch);\n // Compare to \"global mode\"\n\n // let x = 100;\n\n // let y = 100;\n\n // function setup() {\n\n //   createCanvas(200,200);\n\n // }\n\n // function draw() {\n\n //   background(0);\n\n //   fill(255);\n\n //   ellipse(x,y,50,50);\n\n // }"
            },
            {
                "name": "Instance Container",
                "description": "Optionally, you can specify a default container for the canvas and any other elements to append to with a second argument. You can give the ID of an element in your html, or an html node itself. * Here are three different options for selecting a container DOM element. All DOM elements (canvas, buttons, divs, etc) created by p5 will be attached to the DOM element specified as the second argument to the p5() call.",
                "code": ""
            }
        ]
    },
    {
        "groupName": "DOM",
        "examples": [
            {
                "name": "Input and Button",
                "description": "Input text and click the button to see it affect the the canvas.",
                "code": " let input, button, greeting;\n\n function setup() {\n     // create canvas\n     createCanvas(screenWidth, screenHeight);\n     input = createInput();\n     input.position(20, 65);\n     button = createButton('submit');\n     button.position(input.x + input.width, 65);\n     button.mousePressed(greet);\n     greeting = createElement('h2', 'what is your name?');\n     greeting.position(20, 5);\n     textAlign(CENTER);\n     textSize(50);\n }\n\n function greet() {\n     const name = input.value();\n     greeting.html('hello ' + name + '!');\n     input.value('');\n     for (let i = 0; i < 200; i++) {\n         push();\n         fill(random(255), 255, 255);\n         translate(random(width), random(height));\n         rotate(random(2 * PI));\n         text(name, 0, 0);\n         pop();\n     }\n }"
            },
            {
                "name": "Slider",
                "description": "Move the sliders to control the R, G, B values of the background.",
                "code": " let rSlider, gSlider, bSlider;\n\n function setup() {\n     // create canvas\n     createCanvas(screenWidth, screenHeight);\n     textSize(15);\n     noStroke();\n     // create sliders\n     rSlider = createSlider(0, 255, 100);\n     rSlider.position(20, 20);\n     gSlider = createSlider(0, 255, 0);\n     gSlider.position(20, 50);\n     bSlider = createSlider(0, 255, 255);\n     bSlider.position(20, 80);\n }\n\n function draw() {\n     const r = rSlider.value();\n     const g = gSlider.value();\n     const b = bSlider.value();\n     background(r, g, b);\n     text('red', rSlider.x * 2 + rSlider.width, 35);\n     text('green', gSlider.x * 2 + gSlider.width, 65);\n     text('blue', bSlider.x * 2 + bSlider.width, 95);\n }"
            },
            {
                "name": "Modifying the DOM",
                "description": "Create DOM elements and modify their properties every time draw() is called.",
                "code": " let dancingWords = [];\n class DanceSpan {\n     constructor(element, x, y) {\n         element.position(x, y);\n         this.element = element;\n         this.x = x;\n         this.y = y;\n     }\n     brownian() {\n         this.x += random(-6, 6);\n         this.y += random(-6, 6);\n         this.element.position(this.x, this.y);\n     }\n }\n\n function setup() {\n     // This paragraph is created aside of the main block of code.\n\n     // It's to differentiate the creation of an element from its\n\n     // selection. Selected elements don't need to be created by\n\n     // p5js, they can be just plain HTML.\n     createP('I learn in this Letter, that Don Peter of Aragon, ' + ' comes this night to Messina').addClass('text').hide();\n     // This line grabs the paragraph just created, but it would\n\n     // also grab any other elements with class 'text' in the HTML\n\n     // page.\n     const texts = selectAll('.text');\n     for (let i = 0; i < texts.length; i++) {\n         const paragraph = texts[i].html();\n         const words = paragraph.split(' ');\n         for (let j = 0; j < words.length; j++) {\n             const spannedWord = createSpan(words[j]);\n             const dw = new DanceSpan(spannedWord, random(600), random(200));\n             dancingWords.push(dw);\n         }\n     }\n }\n\n function draw() {\n     for (let i = 0; i < dancingWords.length; i++) {\n         dancingWords[i].brownian();\n     }\n }"
            },
            {
                "name": "Video",
                "description": "Load a video with multiple formats and toggle between playing and paused with a button press.",
                "code": " let playing = false;\n let fingers;\n let button;\n\n function setup() {\n     noCanvas();\n     // specify multiple formats for different browsers\n     fingers = createVideo(['assets/fingers.mov', 'assets/fingers.webm']);\n     button = createButton('play');\n     button.mousePressed(toggleVid);\n     // attach button listener\n }\n // plays or pauses the video depending on current state\n function toggleVid() {\n     if (playing) {\n         fingers.pause();\n         button.html('play');\n     } else {\n         fingers.loop();\n         button.html('pause');\n     }\n     playing = !playing;\n }"
            },
            {
                "name": "Video Canvas",
                "description": "Load a video with multiple formats and draw it to the canvas. To run this example locally, you will need a running local server.",
                "code": " let fingers;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     // specify multiple formats for different browsers\n     fingers = createVideo(['assets/fingers.mov', 'assets/fingers.webm']);\n     fingers.hide();\n     // by default video shows up in separate dom\n\n     // element. hide it and draw it to the canvas\n\n     // instead\n }\n\n function draw() {\n     background(150);\n     image(fingers, 10, 10);\n     // draw the video frame to canvas\n     filter(GRAY);\n     image(fingers, 150, 150);\n     // draw a second copy to canvas\n }\n\n function mousePressed() {\n     fingers.loop();\n     // set the video to loop and start playing\n }"
            },
            {
                "name": "Video Pixels",
                "description": "Load a video, manipulate its pixels and draw to canvas. To run this example locally, you will need a running local server.",
                "code": " let fingers;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     // specify multiple formats for different browsers\n     fingers = createVideo(['assets/fingers.mov', 'assets/fingers.webm']);\n     fingers.loop();\n     fingers.hide();\n     noStroke();\n     fill(0);\n }\n\n function draw() {\n     background(255);\n     fingers.loadPixels();\n     const stepSize = round(constrain(mouseX / 8, 6, 32));\n     for (let y = 0; y < height; y += stepSize) {\n         for (let x = 0; x < width; x += stepSize) {\n             const i = y * width + x;\n             const darkness = (255 - fingers.pixels[i * 4]) / 255;\n             const radius = stepSize * darkness;\n             ellipse(x, y, radius, radius);\n         }\n     }\n }"
            },
            {
                "name": "Video Capture",
                "description": "Capture video from the webcam and display on the canvas as well with invert filter. Note that by default the capture feed shows up, too. You can hide the feed by uncommenting the capture.hide() line.",
                "code": ""
            },
            {
                "name": "Drop",
                "description": "Drag an image file onto the canvas to see it displayed.",
                "code": " function setup() {\n     // create canvas\n     const c = createCanvas(screenWidth, screenHeight);\n     background(100);\n     // Add an event for when a file is dropped onto the canvas\n     c.drop(gotFile);\n }\n\n function draw() {\n     fill(255);\n     noStroke();\n     textSize(24);\n     textAlign(CENTER);\n     text('Drag an image file onto the canvas.', width / 2, height / 2);\n     noLoop();\n }\n\n function gotFile(file) {\n     // If it's an image file\n     if (file.type === 'image') {\n         // Create an image DOM element but don't show it\n         const img = createImg(file.data).hide();\n         // Draw the image onto the canvas\n         image(img, 0, 0, width, height);\n     } else {\n         console.log('Not an image file!');\n     }\n }"
            },
            {
                "name": "DOM Form Elements",
                "description": "contributed by Prof WM Harris, How to use p5 DOM form elements to create a slider, button, checkbox, radio group, select menu, and entry field.\nFunctions are created that include: the canvas setup, checkbox creation with text, text box with text that projects typed text onto canvas, slider with button, three selections which project a rectangle in different areas on the canvas depending on selection, and a drop down menu with font change.",
                "code": " /* global variables */\n\n //p5 DOM form elements\n let slider1;\n let button1;\n let checkbox1;\n let radio1;\n let select1;\n let entry1;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     background(\"beige\");\n     checkbox1 = createCheckbox(\"Check me\");\n     createP();\n     //spacer with <p> tag\n     createSpan(\"What's your name? \");\n     //label for entry1\n\n     // createInput([value], [type])\n\n     // type: \"text\" (default), \"number\",\n\n     // \"date\", \"password\", \"email\", etc.\n     entry1 = createInput();\n     //If text in the entry field changes, call\n\n     //the entryCallback function.\n     entry1.changed(entryCallback);\n     createP();\n     //spacer with <p> tag\n\n     //createSlider(min, max, [value], [step])\n     slider1 = createSlider(10, 200);\n     button1 = createButton(\"Press me\");\n     //, \"pressed\");\n\n     //Assign callback fcn for button1\n\n     //when user clicks mouse on it\n     button1.mouseClicked(button1Clicked);\n     createP();\n     //spacer with <p> tag\n     radio1 = createRadio();\n     //.option([value], [contentLabel])\n\n     //If 1 param, it's both content AND\n\n     //value. Values treated as strings.\n     radio1.option(1, \"cranberries\");\n     radio1.option(2, \"almonds\");\n     radio1.option(3, \"gouda\");\n     radio1.value(\"1\");\n     //set init value\n     createP();\n     //spacer with <p> tag\n     select1 = createSelect();\n     //.option([contentValue],[value])\n\n     //If 1 param, it's both content AND\n\n     //value. Values treated as strings.\n     select1.option(\"Sans-serif\");\n     select1.option(\"Serif\");\n     select1.option(\"Fantasy\");\n     //If changed, call select1Changed \n     select1.changed(select1Changed);\n }\n\n function draw() {\n     //get value from slider 1\n     let gray = slider1.value();\n     fill(gray);\n     //If mouse in corner, turn on checkbox1\n     if ((mouseX < width / 3) && (mouseY < height / 3)) {\n         checkbox1.checked(true);\n     }\n     //Is checkbox1 checked? Say so.\n     if (checkbox1.checked()) {\n         text(\"CHECKED\", 20, 40);\n     }\n     switch (radio1.value()) {\n         //radio value is always a string\n         case \"1\":\n             rect(0, 0, width, 50);\n             break;\n         case \"2\":\n             rect(0, 70, width, 50);\n             break;\n         case \"3\":\n             rect(0, 140, width, 50);\n             break;\n     }\n }\n //callback fcn for button1\n function button1Clicked() {\n     //reset slider value to 200\n     slider1.value(200);\n }\n //callback fcn for select1\n function select1Changed() {\n     switch (select1.value()) {\n         case \"Sans-serif\":\n             textFont(\"sans-serif\");\n             break;\n         case \"Serif\":\n             textFont(\"serif\");\n             break;\n         case \"Fantasy\":\n             textFont(\"fantasy\");\n             break;\n     }\n }\n //callback function for entry1\n function entryCallback() {\n     for (let i = 0; i < 25; i++) {\n         text(entry1.value(), random(width), random(height));\n     }\n }\n\n function mouseClicked() {\n     console.log(\"button1?\", button1.value());\n     console.log(\"checkbox1?\", checkbox1.value());\n     //Update .value of either? No visible change\n\n     //to a button or checkbox\n     checkbox1.value(\"Check again\");\n     button1.value(\"clicked?\");\n }\n\n function keyTyped() {\n     switch (key) {\n         case \"r\":\n             //move slider1 value to 100\n             slider1.value(100);\n             break;\n     }\n }"
            }
        ]
    },
    {
        "groupName": "Drawing",
        "examples": [
            {
                "name": "Continuous Lines",
                "description": "Click and drag the mouse to draw a line.",
                "code": " function setup() {\n     createCanvas(screenWidth, screenHeight);\n     background(102);\n }\n\n function draw() {\n     stroke(255);\n     if (mouseIsPressed === true) {\n         line(mouseX, mouseY, pmouseX, pmouseY);\n     }\n }"
            },
            {
                "name": "Patterns",
                "description": "Move the cursor over the image to draw with a software tool which responds to the speed of the mouse.",
                "code": ""
            },
            {
                "name": "Pulses",
                "description": "Software drawing instruments can follow a rhythm or abide by rules independent of drawn gestures. This is a form of collaborative drawing in which the draftsperson controls some aspects of the image and the software controls others.",
                "code": " let angle = 0;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     background(102);\n     noStroke();\n     fill(0, 102);\n }\n\n function draw() {\n     // Draw only when mouse is pressed\n     if (mouseIsPressed === true) {\n         angle += 5;\n         let val = cos(radians(angle)) * 12.0;\n         for (let a = 0; a < 360; a += 75) {\n             let xoff = cos(radians(a)) * val;\n             let yoff = sin(radians(a)) * val;\n             fill(0);\n             ellipse(mouseX + xoff, mouseY + yoff, val, val);\n         }\n         fill(255);\n         ellipse(mouseX, mouseY, 2, 2);\n     }\n }"
            }
        ]
    },
    {
        "groupName": "Transform",
        "examples": [
            {
                "name": "Translate",
                "description": "The translate() function allows objects to be moved to any location within the window. The first parameter sets the x-axis offset and the second parameter sets the y-axis offset. This example shows how transforms accumulate.",
                "code": ""
            },
            {
                "name": "Scale",
                "description": "Paramenters for the scale() function are values specified as decimal percentages. For example, the method call scale(2.0) will increase the dimension of the shape by 200 percent. Objects always scale from the origin. This example shows how transforms accumulate and also how scale and translate interact depending on their order.",
                "code": ""
            },
            {
                "name": "Rotate",
                "description": "Rotating a square around the Z axis. To get the results you expect, send the rotate function angle parameters that are values between 0 and PI*2 (TWO_PI which is roughly 6.28). If you prefer to think about angles as degrees (0-360), you can use the radians() method to convert your values. For example: rotate(radians(90)) is identical to the statement rotate(PI/2). In this example, every even numbered second a jitter is added to the rotation. During odd seconds, rotation moves CW and CCW at the speed determined by the last jitter value.",
                "code": " let angle = 0.0;\n let jitter = 0.0;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     noStroke();\n     fill(255);\n     //Draw the rectangle from the center and it will also be the\n\n     //rotate around that center\n     rectMode(CENTER);\n }\n\n function draw() {\n     background(51);\n     // during even-numbered seconds (0, 2, 4, 6...) add jitter to\n\n     // the rotation\n     if (second() % 2 === 0) {\n         jitter = random(-0.1, 0.1);\n     }\n     //increase the angle value using the most recent jitter value\n     angle = angle + jitter;\n     //use cosine to get a smooth CW and CCW motion when not jittering\n     let c = cos(angle);\n     //move the shape to the center of the canvas\n     translate(width / 2, height / 2);\n     //apply the final rotation\n     rotate(c);\n     rect(0, 0, 180, 180);\n }"
            },
            {
                "name": "Arm",
                "description": "This example uses transform matrices to create an arm. The angle of each segment is controlled with the mouseX and mouseY position. The transformations applied to the first segment are also applied to the second segment because they are inside the same push() and pop() matrix group.",
                "code": " let x, y;\n let angle1 = 0.0;\n let angle2 = 0.0;\n let segLength = 100;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     strokeWeight(30);\n     //Stroke with a semi-transparent white\n     stroke(255, 160);\n     //Position the \"shoulder\" of the arm in the center of the canvas\n     x = width * 0.5;\n     y = height * 0.5;\n }\n\n function draw() {\n     background(0);\n     //Change the angle of the segments according to the mouse positions\n     angle1 = (mouseX / float(width) - 0.5) * -TWO_PI;\n     angle2 = (mouseY / float(height) - 0.5) * PI;\n     //use push and pop to \"contain\" the transforms. Note that\n\n     // even though we draw the segments using a custom function,\n\n     // the transforms still accumulate\n     push();\n     segment(x, y, angle1);\n     segment(segLength, 0, angle2);\n     pop();\n }\n //a custom function for drawing segments\n function segment(x, y, a) {\n     translate(x, y);\n     rotate(a);\n     line(0, 0, segLength, 0);\n }"
            }
        ]
    },
    {
        "groupName": "Typography",
        "examples": [
            {
                "name": "Letters",
                "description": "Letters can be drawn to the screen by loading a font, setting its characteristics and then drawing the letters. This example uses a for loop and unicode reference numbers to automatically fill the canvas with characters in a grid. Vowels are selected and given a specific fill color.",
                "code": " let font, fontsize = 32;\n\n function preload() {\n     // Ensure the .ttf or .otf font stored in the assets directory\n\n     // is loaded before setup() and draw() are called\n     font = loadFont('assets/SourceSansPro-Regular.otf');\n }\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     // Set text characteristics\n     textFont(font);\n     textSize(fontsize);\n     textAlign(CENTER, CENTER);\n }\n\n function draw() {\n     background(160);\n     // Set the gap between letters and the left and top margin\n     let gap = 52;\n     let margin = 10;\n     translate(margin * 4, margin * 4);\n     // Set the counter to start at the character you want\n\n     // in this case 35, which is the # symbol\n     let counter = 35;\n     // Loop as long as there is space on the canvas\n     for (let y = 0; y < height - gap; y += gap) {\n         for (let x = 0; x < width - gap; x += gap) {\n             // Use the counter to retrieve individual letters by their Unicode number\n             let letter = char(counter);\n             // Add different color to the vowels and other characters\n             if (letter === 'A' || letter === 'E' || letter === 'I' || letter === 'O' || letter === 'U') {\n                 fill('#ed225d');\n             } else {\n                 fill(255);\n             }\n             // Draw the letter to the screen\n             text(letter, x, y);\n             // Increment the counter\n             counter++;\n         }\n     }\n }"
            },
            {
                "name": "Words",
                "description": "The text() function is used for writing words to the screen. The words can be aligned left, center, or right with the textAlign() function, and like with shapes, words can be colored with fill().",
                "code": ""
            },
            {
                "name": "Text Rotation",
                "description": "Draws letters to the screen and rotates them at different angles.\n\nThis example is ported from the Text Rotation example on the Processing website",
                "code": ""
            }
        ]
    },
    {
        "groupName": "3D",
        "examples": [
            {
                "name": "Geometries",
                "description": "There are six 3D primitives in p5 now.",
                "code": ""
            },
            {
                "name": "Sine Cosine in 3D",
                "description": "Sine, cosine and push / pop could be applied in 3D as well.",
                "code": " function setup() {\n     createCanvas(screenWidth, screenHeight, WEBGL);\n }\n\n function draw() {\n     background(250);\n     rotateY(frameCount * 0.01);\n     for (let j = 0; j < 5; j++) {\n         push();\n         for (let i = 0; i < 80; i++) {\n             translate(sin(frameCount * 0.001 + j) * 100, sin(frameCount * 0.001 + j) * 100, i * 0.1);\n             rotateZ(frameCount * 0.002);\n             push();\n             sphere(8, 6, 4);\n             pop();\n         }\n         pop();\n     }\n }"
            },
            {
                "name": "Multiple Lights",
                "description": "All types of lights could be used in one sketch.",
                "code": " function setup() {\n     createCanvas(screenWidth, screenHeight, WEBGL);\n }\n\n function draw() {\n     background(0);\n     let locX = mouseX - height / 2;\n     let locY = mouseY - width / 2;\n     ambientLight(50);\n     directionalLight(255, 0, 0, 0.25, 0.25, 0);\n     pointLight(0, 0, 255, locX, locY, 250);\n     push();\n     translate(-width / 4, 0, 0);\n     rotateZ(frameCount * 0.02);\n     rotateX(frameCount * 0.02);\n     specularMaterial(250);\n     box(100, 100, 100);\n     pop();\n     translate(width / 4, 0, 0);\n     ambientMaterial(250);\n     sphere(120, 64);\n }"
            },
            {
                "name": "Materials",
                "description": "There are five types of materials supported. They respond to light differently. Move your mouse to change the light position.",
                "code": ""
            },
            {
                "name": "Textures",
                "description": "Images and videos are supported for texture.",
                "code": " // video source: https://vimeo.com/90312869\n let img;\n let vid;\n let theta = 0;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight, WEBGL);\n     img = loadImage('assets/cat.jpg');\n     vid = createVideo(['assets/360video_256crop_v2.mp4']);\n     vid.elt.muted = true;\n     vid.loop();\n     vid.hide();\n }\n\n function draw() {\n     background(250);\n     translate(-220, 0, 0);\n     push();\n     rotateZ(theta * mouseX * 0.001);\n     rotateX(theta * mouseX * 0.001);\n     rotateY(theta * mouseX * 0.001);\n     //pass image as texture\n     texture(vid);\n     sphere(150);\n     pop();\n     translate(440, 0, 0);\n     push();\n     rotateZ(theta * 0.1);\n     rotateX(theta * 0.1);\n     rotateY(theta * 0.1);\n     texture(img);\n     box(100, 100, 100);\n     pop();\n     theta += 0.05;\n }"
            },
            {
                "name": "Ray Casting",
                "description": "Original example by Jonathan Watson.\n\nDetecting the position of the mouse in 3D space with ray casting.",
                "code": " const objects = [];\n let eyeZ;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight, WEBGL);\n     eyeZ = height / 2 / tan((30 * PI) / 180);\n     // The default distance the camera is away from the origin.\n     objects.push(new IntersectPlane(1, 0, 0, -100, 0, 0));\n     // Left wall\n     objects.push(new IntersectPlane(1, 0, 0, 100, 0, 0));\n     // Right wall\n     objects.push(new IntersectPlane(0, 1, 0, 0, -100, 0));\n     // Bottom wall\n     objects.push(new IntersectPlane(0, 1, 0, 0, 100, 0));\n     // Top wall\n     objects.push(new IntersectPlane(0, 0, 1, 0, 0, 0));\n     // Back wall\n     noStroke();\n     ambientMaterial(250);\n }\n\n function draw() {\n     background(0);\n     // Lights\n     pointLight(255, 255, 255, 0, 0, 400);\n     ambientLight(244, 122, 158);\n     // Left wall\n     push();\n     translate(-100, 0, 200);\n     rotateY((90 * PI) / 180);\n     plane(400, 200);\n     pop();\n     // Right wall\n     push();\n     translate(100, 0, 200);\n     rotateY((90 * PI) / 180);\n     plane(400, 200);\n     pop();\n     // Bottom wall\n     push();\n     translate(0, 100, 200);\n     rotateX((90 * PI) / 180);\n     plane(200, 400);\n     pop();\n     // Top wall\n     push();\n     translate(0, -100, 200);\n     rotateX((90 * PI) / 180);\n     plane(200, 400);\n     pop();\n     plane(200, 200);\n     // Back wall\n     const x = mouseX - width / 2;\n     const y = mouseY - height / 2;\n     const Q = createVector(0, 0, eyeZ);\n     // A point on the ray and the default position of the camera.\n     const v = createVector(x, y, -eyeZ);\n     // The direction vector of the ray.\n     let intersect;\n     // The point of intersection between the ray and a plane.\n     let closestLambda = eyeZ * 10;\n     // The draw distance.\n     for (let x = 0; x < objects.length; x += 1) {\n         let object = objects[x];\n         let lambda = object.getLambda(Q, v);\n         // The value of lambda where the ray intersects the object\n         if (lambda < closestLambda && lambda > 0) {\n             // Find the position of the intersection of the ray and the object.\n             intersect = p5.Vector.add(Q, p5.Vector.mult(v, lambda));\n             closestLambda = lambda;\n         }\n     }\n     // Cursor\n     push();\n     translate(intersect);\n     fill(237, 34, 93);\n     sphere(10);\n     pop();\n }\n // Class for a plane that extends to infinity.\n class IntersectPlane {\n     constructor(n1, n2, n3, p1, p2, p3) {\n         this.normal = createVector(n1, n2, n3);\n         // The normal vector of the plane\n         this.point = createVector(p1, p2, p3);\n         // A point on the plane\n         this.d = this.point.dot(this.normal);\n     }\n     getLambda(Q, v) {\n         return (-this.d - this.normal.dot(Q)) / this.normal.dot(v);\n     }\n }"
            },
            {
                "name": "Orbit Control",
                "description": "Orbit control allows you to drag and move around the world.",
                "code": ""
            },
            {
                "name": "Basic Shader",
                "description": "This is a basic example showing how to load shaders in p5.js.\nTo learn more about using shaders in p5.js: p5.js Shaders",
                "code": " // this variable will hold our shader object\n let theShader;\n\n function preload() {\n     // load the shader\n     theShader = loadShader('assets/basic.vert', 'assets/basic.frag');\n }\n\n function setup() {\n     // shaders require WEBGL mode to work\n     createCanvas(screenWidth, screenHeight, WEBGL);\n     noStroke();\n }\n\n function draw() {\n     // shader() sets the active shader with our shader\n     shader(theShader);\n     // rect gives us some geometry on the screen\n     rect(0, 0, width, height);\n }"
            },
            {
                "name": "Shader as a Texture",
                "description": "Shaders can be applied to 2D/3D shapes as textures.\nTo learn more about using shaders in p5.js: p5.js Shaders",
                "code": ""
            },
            {
                "name": "Passing Shader Uniforms",
                "description": "Uniforms are the way in which information is passed from p5 to the shader.\nTo learn more about using shaders in p5.js: p5.js Shaders",
                "code": " // this variable will hold our shader object\n let theShader;\n\n function preload() {\n     // load the shader\n     theShader = loadShader('assets/uniforms.vert', 'assets/uniforms.frag');\n }\n\n function setup() {\n     // shaders require WEBGL mode to work\n     createCanvas(screenWidth, screenHeight, WEBGL);\n     noStroke();\n }\n\n function draw() {\n     // shader() sets the active shader with our shader\n     shader(theShader);\n     // lets send the resolution, mouse, and time to our shader\n\n     // before sending mouse + time we modify the data so it's more easily usable by the shader\n     theShader.setUniform('resolution', [width, height]);\n     theShader.setUniform('mouse', map(mouseX, 0, width, 0, 7));\n     theShader.setUniform('time', frameCount * 0.01);\n     // rect gives us some geometry on the screen\n     rect(0, 0, width, height);\n }"
            },
            {
                "name": "Shader Using Webcam",
                "description": "The webcam can be passed to shaders as a texture.\nTo learn more about using shaders in p5.js: p5.js Shaders",
                "code": " // this variable will hold our shader object\n let theShader;\n // this variable will hold our webcam video\n let cam;\n\n function preload() {\n     // load the shader\n     theShader = loadShader('assets/webcam.vert', 'assets/webcam.frag');\n }\n\n function setup() {\n     // shaders require WEBGL mode to work\n     createCanvas(screenWidth, screenHeight, WEBGL);\n     noStroke();\n     cam = createCapture(VIDEO);\n     cam.size(710, 400);\n     cam.hide();\n }\n\n function draw() {\n     // shader() sets the active shader with our shader\n     shader(theShader);\n     // passing cam as a texture\n     theShader.setUniform('tex0', cam);\n     // rect gives us some geometry on the screen\n     rect(0, 0, width, height);\n }"
            },
            {
                "name": "Blur using Framebuffer Depth",
                "description": "A shader that uses depth information from a p5.Framebuffer to draw a scene with focal blur.",
                "code": " let layer;\n let blur;\n\n function setup() {\n     createCanvas(windowWidth, windowHeight, WEBGL);\n     layer = createFramebuffer();\n     blur = createShader(vert, frag);\n     noStroke();\n }\n\n function draw() {\n     // Draw a scene\n     layer.begin();\n     background(255);\n     ambientLight(100);\n     directionalLight(255, 255, 255, -1, 1, -1);\n     ambientMaterial(255, 0, 0);\n     fill(255, 255, 100);\n     specularMaterial(255);\n     shininess(150);\n     rotateY(millis() * 0.001);\n     for (let i = 0; i < 5; i++) {\n         push();\n         translate((i - 2) * 100, 0, 0);\n         sphere();\n         pop();\n     }\n     layer.end();\n     // Render the scene with depth of field blur\n     shader(blur);\n     blur.setUniform('img', layer.color);\n     blur.setUniform('depth', layer.depth);\n     rect(0, 0, width, height);\n }\n\n function windowResized() {\n     resizeCanvas(windowWidth, windowHeight);\n }\n let vert = precision highp float;\n attribute vec3 aPosition;\n attribute vec2 aTexCoord;\n varying vec2 vTexCoord;\n void main() {\n     vec4 positionVec4 = vec4(aPosition, 1.0);\n     positionVec4.xy = positionVec4.xy * 2.0 - 1.0;\n     positionVec4.y *= -1.0;\n     gl_Position = positionVec4;\n     vTexCoord = aTexCoord;\n };\n let frag = precision highp float;\n varying vec2 vTexCoord;\n uniform sampler2D img;\n uniform sampler2D depth;\n float getBlurriness(float d) {\n     // Blur more the farther away we go from the\n\n     // focal point at depth=0.9\n     return abs(d - 0.9) * 40 .;\n }\n float maxBlurDistance(float blurriness) {\n     return blurriness * 0.01;\n }\n void main() {\n     vec4 color = texture2D(img, vTexCoord);\n     float samples = 1 .;\n     float centerDepth = texture2D(depth, vTexCoord).r;\n     float blurriness = getBlurriness(centerDepth);\n     for (int sample = 0; sample < 20; sample++) {\n         // Sample nearby pixels in a spiral going out from the\n\n         // current pixel\n         float angle = float(sample);\n         float distance = float(sample) / 20 .*maxBlurDistance(blurriness);\n         vec2 offset = vec2(cos(angle), sin(angle)) * distance;\n         // How close is the object at the nearby pixel?\n         float sampleDepth = texture2D(depth, vTexCoord + offset).r;\n         // How far should its blur reach?\n         float sampleBlurDistance = maxBlurDistance(getBlurriness(sampleDepth));\n         // If it's in front of the current pixel, or its blur overlaps\n\n         // with the current pixel, add its color to the average\n         if (sampleDepth >= centerDepth || sampleBlurDistance >= distance) {\n             color += texture2D(img, vTexCoord + offset);\n             samples++;\n         }\n     }\n     color /= samples;\n     gl_FragColor = color;\n };"
            }
        ]
    },
    {
        "groupName": "Input",
        "examples": [
            {
                "name": "Clock",
                "description": "The current time can be read with the second(), minute(), and hour() functions. In this example, sin() and cos() values are used to set the position of the hands.",
                "code": " let cx, cy;\n let secondsRadius;\n let minutesRadius;\n let hoursRadius;\n let clockDiameter;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     stroke(255);\n     let radius = min(width, height) / 2;\n     secondsRadius = radius * 0.71;\n     minutesRadius = radius * 0.6;\n     hoursRadius = radius * 0.5;\n     clockDiameter = radius * 1.7;\n     cx = width / 2;\n     cy = height / 2;\n }\n\n function draw() {\n     background(230);\n     // Draw the clock background\n     noStroke();\n     fill(244, 122, 158);\n     ellipse(cx, cy, clockDiameter + 25, clockDiameter + 25);\n     fill(237, 34, 93);\n     ellipse(cx, cy, clockDiameter, clockDiameter);\n     // Angles for sin() and cos() start at 3 o'clock;\n\n     // subtract HALF_PI to make them start at the top\n     let s = map(second(), 0, 60, 0, TWO_PI) - HALF_PI;\n     let m = map(minute() + norm(second(), 0, 60), 0, 60, 0, TWO_PI) - HALF_PI;\n     let h = map(hour() + norm(minute(), 0, 60), 0, 24, 0, TWO_PI * 2) - HALF_PI;\n     // Draw the hands of the clock\n     stroke(255);\n     strokeWeight(1);\n     line(cx, cy, cx + cos(s) * secondsRadius, cy + sin(s) * secondsRadius);\n     strokeWeight(2);\n     line(cx, cy, cx + cos(m) * minutesRadius, cy + sin(m) * minutesRadius);\n     strokeWeight(4);\n     line(cx, cy, cx + cos(h) * hoursRadius, cy + sin(h) * hoursRadius);\n     // Draw the minute ticks\n     strokeWeight(2);\n     beginShape(POINTS);\n     for (let a = 0; a < 360; a += 6) {\n         let angle = radians(a);\n         let x = cx + cos(angle) * secondsRadius;\n         let y = cy + sin(angle) * secondsRadius;\n         vertex(x, y);\n     }\n     endShape();\n }"
            },
            {
                "name": "Constrain",
                "description": "Move the mouse across the screen to move the circle. The program constrains the circle to its box.",
                "code": " let mx = 1;\n let my = 1;\n let easing = 0.05;\n let radius = 24;\n let edge = 100;\n let inner = edge + radius;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     noStroke();\n     ellipseMode(RADIUS);\n     rectMode(CORNERS);\n }\n\n function draw() {\n     background(230);\n     if (abs(mouseX - mx) > 0.1) {\n         mx = mx + (mouseX - mx) * easing;\n     }\n     if (abs(mouseY - my) > 0.1) {\n         my = my + (mouseY - my) * easing;\n     }\n     mx = constrain(mx, inner, width - inner);\n     my = constrain(my, inner, height - inner);\n     fill(237, 34, 93);\n     rect(edge, edge, width - edge, height - edge);\n     fill(255);\n     ellipse(mx, my, radius, radius);\n }"
            },
            {
                "name": "Easing",
                "description": "Move the mouse across the screen and the symbol will follow. Between drawing each frame of the animation, the program calculates the difference between the position of the symbol and the cursor. If the distance is larger than 1 pixel, the symbol moves part of the distance (0.05) from its current position toward the cursor.",
                "code": " let x = 1;\n let y = 1;\n let easing = 0.05;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     noStroke();\n }\n\n function draw() {\n     background(237, 34, 93);\n     let targetX = mouseX;\n     let dx = targetX - x;\n     x += dx * easing;\n     let targetY = mouseY;\n     let dy = targetY - y;\n     y += dy * easing;\n     ellipse(x, y, 66, 66);\n }"
            },
            {
                "name": "Keyboard",
                "description": "Click on the image to give it focus and press the letter keys to create forms in time and space. Each key has a unique identifying number. These numbers can be used to position shapes in space.",
                "code": " let rectWidth;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     noStroke();\n     background(230);\n     rectWidth = width / 4;\n }\n\n function draw() {\n     // keep draw() here to continue looping while waiting for keys\n }\n\n function keyPressed() {\n     let keyIndex = -1;\n     if (key >= 'a' && key <= 'z') {\n         keyIndex = key.charCodeAt(0) - 'a'.charCodeAt(0);\n     }\n     if (keyIndex === -1) {\n         // If it's not a letter key, clear the screen\n         background(230);\n     } else {\n         // It's a letter key, fill a rectangle\n         randFill_r = Math.floor(Math.random() * 255 + 1);\n         randFill_g = Math.floor(Math.random() * 255 + 1);\n         randFill_b = Math.floor(Math.random() * 255 + 1);\n         fill(randFill_r, randFill_g, randFill_b);\n         let x = map(keyIndex, 0, 25, 0, width - rectWidth);\n         rect(x, 0, rectWidth, height);\n     }\n }"
            },
            {
                "name": "Milliseconds",
                "description": "A millisecond is 1/1000 of a second. Processing keeps track of the number of milliseconds a program has run. By modifying this number with the modulo(%) operator, different patterns in time are created.\n\nThis example is ported from the Milliseconds example on the Processing website",
                "code": " let scale;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     noStroke();\n     scale = width / 20;\n }\n\n function draw() {\n     let i;\n     for (i = 0; i < scale; i++) {\n         colorMode(RGB, (i + 1) * scale * 10);\n         fill(millis() % ((i + 1) * scale * 10));\n         rect(i * scale, 0, scale, height);\n     }\n }"
            },
            {
                "name": "Mouse 1D",
                "description": "Move the mouse left and right to shift the balance. The \"mouseX\" variable is used to control both the size and color of the rectangles.",
                "code": ""
            },
            {
                "name": "Mouse 2D",
                "description": "Moving the mouse changes the position and size of each box.",
                "code": " function setup() {\n     createCanvas(screenWidth, screenHeight);\n     noStroke();\n     rectMode(CENTER);\n }\n\n function draw() {\n     background(230);\n     fill(244, 122, 158);\n     rect(mouseX, height / 2, mouseY / 2 + 10, mouseY / 2 + 10);\n     fill(237, 34, 93);\n     let inverseX = width - mouseX;\n     let inverseY = height - mouseY;\n     rect(inverseX, height / 2, inverseY / 2 + 10, inverseY / 2 + 10);\n }"
            },
            {
                "name": "Mouse Functions",
                "description": "Click on the box and drag it across the screen.",
                "code": " let bx;\n let by;\n let boxSize = 75;\n let overBox = false;\n let locked = false;\n let xOffset = 0.0;\n let yOffset = 0.0;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     bx = width / 2.0;\n     by = height / 2.0;\n     rectMode(RADIUS);\n     strokeWeight(2);\n }\n\n function draw() {\n     background(237, 34, 93);\n     // Test if the cursor is over the box\n     if (mouseX > bx - boxSize && mouseX < bx + boxSize && mouseY > by - boxSize && mouseY < by + boxSize) {\n         overBox = true;\n         if (!locked) {\n             stroke(255);\n             fill(244, 122, 158);\n         }\n     } else {\n         stroke(156, 39, 176);\n         fill(244, 122, 158);\n         overBox = false;\n     }\n     // Draw the box\n     rect(bx, by, boxSize, boxSize);\n }\n\n function mousePressed() {\n     if (overBox) {\n         locked = true;\n         fill(255, 255, 255);\n     } else {\n         locked = false;\n     }\n     xOffset = mouseX - bx;\n     yOffset = mouseY - by;\n }\n\n function mouseDragged() {\n     if (locked) {\n         bx = mouseX - xOffset;\n         by = mouseY - yOffset;\n     }\n }\n\n function mouseReleased() {\n     locked = false;\n }"
            },
            {
                "name": "Mouse Signals",
                "description": "Move and click the mouse to generate signals. The top row is the signal from \"mouseX\", the middle row is the signal from \"mouseY\", and the bottom row is the signal from \"mouseIsPressed\".",
                "code": " let xvals = [];\n let yvals = [];\n let bvals = [];\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     strokeWeight(2);\n }\n\n function draw() {\n     background(237, 34, 93);\n     for (let i = 1; i < width; i++) {\n         xvals[i - 1] = xvals[i];\n         yvals[i - 1] = yvals[i];\n         bvals[i - 1] = bvals[i];\n     }\n     // Add the new values to the end of the array\n     xvals[width - 1] = mouseX;\n     yvals[width - 1] = mouseY;\n     if (mouseIsPressed) {\n         bvals[width - 1] = 0;\n     } else {\n         bvals[width - 1] = 255;\n     }\n     fill(255);\n     noStroke();\n     rect(0, height / 3, width, height / 3 + 1);\n     for (let i = 1; i < width; i++) {\n         stroke(255);\n         point(i, xvals[i] / 3);\n         stroke(0);\n         point(i, height / 3 + yvals[i] / 3);\n         stroke(255);\n         line(i, (2 * height) / 3 + bvals[i] / 3, i, (2 * height) / 3 + bvals[i - 1] / 3);\n     }\n }"
            },
            {
                "name": "Mouse Press",
                "description": "Move the mouse to position the shape. Press the mouse button to invert the color.",
                "code": " function setup() {\n     createCanvas(screenWidth, screenHeight);\n     background(230);\n     strokeWeight(2);\n }\n\n function draw() {\n     if (mouseIsPressed) {\n         stroke(255);\n     } else {\n         stroke(237, 34, 93);\n     }\n     line(mouseX - 66, mouseY, mouseX + 66, mouseY);\n     line(mouseX, mouseY - 66, mouseX, mouseY + 66);\n }"
            },
            {
                "name": "Rollover",
                "description": "Roll over the colored squares in the center of the image to change the color of the outside rectangle.\n\nThis example is ported from the Rollover example on the Processing website",
                "code": " let squareX, squareY;\n // Position of square button\n let circleX, circleY;\n // Position of circle button\n let squareSize = 90;\n // Width/height of square\n let circleSize = 93;\n // Diameter of circle\n let squareColor;\n let circleColor;\n let baseColor;\n let squareOver = false;\n let circleOver = false;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     squareColor = color(0);\n     circleColor = color(255);\n     baseColor = color(102);\n     circleX = width / 2 + circleSize / 2 + 10;\n     circleY = height / 2;\n     squareX = width / 2 - squareSize - 10;\n     squareY = height / 2 - squareSize / 2;\n }\n\n function draw() {\n     update(mouseX, mouseY);\n     noStroke();\n     if (squareOver) {\n         background(squareColor);\n     } else if (circleOver) {\n         background(circleColor);\n     } else {\n         background(baseColor);\n     }\n     stroke(255);\n     fill(squareColor);\n     square(squareX, squareY, squareSize);\n     stroke(0);\n     fill(circleColor);\n     circle(circleX, circleY, circleSize);\n }\n\n function update(x, y) {\n     if (overCircle(circleX, circleY, circleSize)) {\n         circleOver = true;\n         squareOver = false;\n     } else if (overSquare(squareX, squareY, squareSize)) {\n         squareOver = true;\n         circleOver = false;\n     } else {\n         circleOver = squareOver = false;\n     }\n }\n\n function overSquare(x, y, size) {\n     if (mouseX >= x && mouseX <= x + size && mouseY >= y && mouseY <= y + size) {\n         return true;\n     } else {\n         return false;\n     }\n }\n\n function overCircle(x, y, diameter) {\n     const disX = x - mouseX;\n     const disY = y - mouseY;\n     if (sqrt(sq(disX) + sq(disY)) < diameter / 2) {\n         return true;\n     } else {\n         return false;\n     }\n }"
            },
            {
                "name": "Storing Input",
                "description": "Move the mouse across the screen to change the position of the circles. The positions of the mouse are recorded into an array and played back every frame. Between each frame, the newest value are added to the end of each array and the oldest value is deleted.",
                "code": " let num = 60;\n let mx = [];\n let my = [];\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     noStroke();\n     fill(255, 153);\n     for (let i = 0; i < num; i++) {\n         mx.push(i);\n         my.push(i);\n     }\n }\n\n function draw() {\n     background(237, 34, 93);\n     // Cycle through the array, using a different entry on each frame.\n\n     // Using modulo (%) like this is faster than moving all the values over.\n     let which = frameCount % num;\n     mx[which] = mouseX;\n     my[which] = mouseY;\n     for (let i = 0; i < num; i++) {\n         // which+1 is the smallest (the oldest in the array)\n         let index = (which + 1 + i) % num;\n         ellipse(mx[index], my[index], i, i);\n     }\n }"
            }
        ]
    },
    {
        "groupName": "Advanced Data",
        "examples": [
            {
                "name": "Load Saved JSON",
                "description": "Create a Bubble class, instantiate multiple bubbles using data from a JSON file, and display results on the screen. Because web browsers differ in where they save files, we do not make use of saveJSON(), unlike the Processing example.\n\nBased on Daniel Shiffman's LoadSaveJSON Example for Processing.",
                "code": " // Bubble class\n class Bubble {\n     constructor(x, y, diameter, name) {\n         this.x = x;\n         this.y = y;\n         this.diameter = diameter;\n         this.radius = diameter / 2;\n         this.name = name;\n         this.over = false;\n     }\n     // Check if mouse is over the bubble\n     rollover(px, py) {\n         let d = dist(px, py, this.x, this.y);\n         this.over = d < this.radius;\n     }\n     // Display the Bubble\n     display() {\n         stroke(0);\n         strokeWeight(0.8);\n         noFill();\n         ellipse(this.x, this.y, this.diameter, this.diameter);\n         if (this.over) {\n             fill(0);\n             textAlign(CENTER);\n             text(this.name, this.x, this.y + this.radius + 20);\n         }\n     }\n }\n let data = {};\n // Global object to hold results from the loadJSON call\n let bubbles = [];\n // Global array to hold all bubble objects\n\n // Put any asynchronous data loading in preload to complete before \"setup\" is run\n function preload() {\n     data = loadJSON('assets/bubbles.json');\n }\n // Convert saved Bubble data into Bubble Objects\n function loadData() {\n     let bubbleData = data['bubbles'];\n     for (let i = 0; i < bubbleData.length; i++) {\n         // Get each object in the array\n         let bubble = bubbleData[i];\n         // Get a position object\n         let position = bubble['position'];\n         // Get x,y from position\n         let x = position['x'];\n         let y = position['y'];\n         // Get diameter and label\n         let diameter = bubble['diameter'];\n         let label = bubble['label'];\n         // Put object in array\n         bubbles.push(new Bubble(x, y, diameter, label));\n     }\n }\n // Create a new Bubble each time the mouse is clicked.\n function mousePressed() {\n     // Add diameter and label to bubble\n     let diameter = random(40, 80);\n     let label = 'New Label';\n     // Append the new JSON bubble object to the array\n     bubbles.push(new Bubble(mouseX, mouseY, diameter, label));\n     // Prune Bubble Count if there are too many\n     if (bubbles.length > 10) {\n         bubbles.shift();\n         // remove first item from array\n     }\n }\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     loadData();\n }\n\n function draw() {\n     background(255);\n     // Display all bubbles\n     for (let i = 0; i < bubbles.length; i++) {\n         bubbles[i].display();\n         bubbles[i].rollover(mouseX, mouseY);\n     }\n     // Label directions at bottom\n     textAlign(LEFT);\n     fill(0);\n     text('Click to add bubbles.', 10, height - 10);\n }"
            },
            {
                "name": "Load Saved Table",
                "description": "Create a Bubble class, instantiate multiple bubbles using data from a csv file, and display results on the screen. Because web browsers differ in where they save files, we do not make use of saveTable(), unlike the Processing example.\n\nBased on Daniel Shiffman's LoadSaveTable Example for Processing.",
                "code": " // Bubble class\n class Bubble {\n     constructor(x, y, diameter, name) {\n         this.x = x;\n         this.y = y;\n         this.diameter = diameter;\n         this.radius = diameter / 2;\n         this.name = name;\n         this.over = false;\n     }\n     // Check if mouse is over the bubble\n     rollover(px, py) {\n         let d = dist(px, py, this.x, this.y);\n         this.over = d < this.radius;\n     }\n     // Display the Bubble\n     display() {\n         stroke(0);\n         strokeWeight(0.8);\n         noFill();\n         ellipse(this.x, this.y, this.diameter, this.diameter);\n         if (this.over) {\n             fill(0);\n             textAlign(CENTER);\n             text(this.name, this.x, this.y + this.radius + 20);\n         }\n     }\n }\n let table;\n // Global object to hold results from the loadTable call\n let bubbles = [];\n // Global array to hold all bubble objects\n\n // Put any asynchronous data loading in preload to complete before \"setup\" is run\n function preload() {\n     table = loadTable(\"assets/bubbles.csv\", \"header\");\n }\n // Convert saved Bubble data into Bubble Objects\n function loadData() {\n     const bubbleData = table.getRows();\n     // The size of the array of Bubble objects is determined by the total number of rows in the CSV\n     const length = table.getRowCount();\n     for (let i = 0; i < length; i++) {\n         // Get position, diameter, name,\n         const x = bubbleData[i].getNum(\"x\");\n         const y = bubbleData[i].getNum(\"y\");\n         const diameter = bubbleData[i].getNum(\"diameter\");\n         const name = bubbleData[i].getString(\"name\");\n         // Put object in array\n         bubbles.push(new Bubble(x, y, diameter, name));\n     }\n }\n // Create a new Bubble each time the mouse is clicked.\n function mousePressed() {\n     // Create a new row\n     let row = table.addRow();\n     let name = \"New Bubble\";\n     let diameter = random(40, 80);\n     // Set the values of that row\n     row.setNum(\"x\", mouseX);\n     row.setNum(\"y\", mouseY);\n     row.setNum(\"diameter\", diameter);\n     row.setString(\"name\", name);\n     bubbles.push(new Bubble(mouseX, mouseY, diameter, name));\n     // If the table has more than 10 rows\n     if (table.getRowCount() > 10) {\n         // Delete the oldest row\n         table.removeRow(0);\n         bubbles.shift();\n     }\n }\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     loadData();\n }\n\n function draw() {\n     background(255);\n     // Display all bubbles\n     for (let i = 0; i < bubbles.length; i++) {\n         bubbles[i].display();\n         bubbles[i].rollover(mouseX, mouseY);\n     }\n     // Label directions at bottom\n     textAlign(LEFT);\n     fill(0);\n     text(\"Click to add bubbles.\", 10, height - 10);\n }"
            }
        ]
    },
    {
        "groupName": "Sound",
        "examples": [
            {
                "name": "Load and Play Sound",
                "description": "Load sound during preload(). Play a sound when canvas is clicked.\n\nTo run this example locally, you will need the p5.sound library a sound file, and a running local server.",
                "code": " let song;\n\n function setup() {\n     song = loadSound('assets/lucky_dragons_-_power_melody.mp3');\n     createCanvas(screenWidth, screenHeight);\n     background(255, 0, 0);\n }\n\n function mousePressed() {\n     if (song.isPlaying()) {\n         // .isPlaying() returns a boolean\n         song.stop();\n         background(255, 0, 0);\n     } else {\n         song.play();\n         background(0, 255, 0);\n     }\n }"
            },
            {
                "name": "Preload SoundFile",
                "description": "Call loadSound() during preload() to ensure that the sound is completely loaded before setup() is called. It's best to always call loadSound() in preload(), otherwise sounds won't necessarily be loaded by the time you want to play them in your sketch. *\n\nTo run this example locally, you will need the p5.sound library a sound file, and a running local server.",
                "code": " let song;\n\n function preload() {\n     song = loadSound('assets/lucky_dragons_-_power_melody.mp3');\n }\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     song.loop();\n     // song is ready to play during setup() because it was loaded during preload\n     background(0, 255, 0);\n }\n\n function mousePressed() {\n     if (song.isPlaying()) {\n         // .isPlaying() returns a boolean\n         song.pause();\n         // .play() will resume from .pause() position\n         background(255, 0, 0);\n     } else {\n         song.play();\n         background(0, 255, 0);\n     }\n }"
            },
            {
                "name": "soundFormats",
                "description": "Technically, due to patent issues, there is no single sound format that is supported by all web browsers. While mp3 is supported across the latest versions of major browsers on OS X and Windows, for example, it may not be available on some less mainstream operating systems and browsers.\n\n*\n\nTo ensure full compatibility, you can include the same sound file in multiple formats, e.g. 'sound.mp3' and 'sound.ogg'. (Ogg is an open source alternative to mp3.) You can convert audio files into web friendly formats for free online at media.io\n\n. *\n\nThe soundFormats() method tells loadSound which formats we have included with our sketch. Then, loadSound will attempt to load the first format that is supported by the client's web browser.\n\n*\n\nTo run this example locally, you will need the p5.sound library a sound file, and a running local server.",
                "code": " let song;\n\n function preload() {\n     // we have included both an .ogg file and an .mp3 file\n     soundFormats('ogg', 'mp3');\n     // if mp3 is not supported by this browser,\n\n     // loadSound will load the ogg file\n\n     // we have included with our sketch\n     song = loadSound('assets/lucky_dragons_-_power_melody.mp3');\n }\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     // song loaded during preload(), ready to play in setup()\n     song.play();\n     background(0, 255, 0);\n }\n\n function mousePressed() {\n     if (song.isPlaying()) {\n         // .isPlaying() returns a boolean\n         song.pause();\n         background(255, 0, 0);\n     } else {\n         song.play();\n         // playback will resume from the pause position\n         background(0, 255, 0);\n     }\n }"
            },
            {
                "name": "Play Mode",
                "description": "In 'sustain' mode, the sound will overlap with itself. In 'restart' mode it will stop and then start again. Click mouse to play a sound file. Trigger lots of sounds at once! Press any key to change playmode.\n\nTo run this example locally, you will need the p5.sound library a sound file, and a running local server.",
                "code": " let playMode = 'sustain';\n let sample;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     soundFormats('mp3', 'ogg');\n     sample = loadSound('assets/Damscray_-_Dancing_Tiger_02.mp3');\n }\n\n function draw() {\n     background(255, 255, 0);\n     let str = 'Click here to play! Press key to toggle play mode.';\n     str += ' Current Play Mode: ' + playMode + '.';\n     text(str, 10, height / 2);\n }\n\n function mouseClicked() {\n     sample.play();\n }\n\n function keyPressed(k) {\n     togglePlayMode();\n }\n\n function togglePlayMode() {\n     if (playMode === 'sustain') {\n         playMode = 'restart';\n     } else {\n         playMode = 'sustain';\n     }\n     sample.playMode(playMode);\n }"
            },
            {
                "name": "Pan Sound",
                "description": "Click mouse to play the sound. Ball position follows mouse and correlates to panning of sound.\n\nTo run this example locally, you will need the p5.sound library a sound file, and a running local server.\n\n*",
                "code": " let ball = {};\n let soundFile;\n\n function preload() {\n     soundFormats('mp3', 'ogg');\n     soundFile = loadSound('assets/beatbox.ogg');\n }\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n }\n\n function draw() {\n     background(0);\n     ball.x = constrain(mouseX, 0, width);\n     ellipse(ball.x, height / 2, 100, 100);\n }\n\n function mousePressed() {\n     // map the ball's x location to a panning degree\n\n     // between -1.0 (left) and 1.0 (right)\n     let panning = map(ball.x, 0, width, -1.0, 1.0);\n     soundFile.pan(panning);\n     soundFile.play();\n }"
            },
            {
                "name": "Sound Effect",
                "description": "Play a sound effect when the mouse is clicked inside the circle.\n\nTo run this example locally, you will need the p5.sound library a sound file, and a running local server.",
                "code": " // Adapted from Learning Processing by Daniel Shiffman\n\n // http://www.learningprocessing.com\n\n // Doorbell sample by Corsica_S via freesound.org,\n\n // Creative Commons BY 3.0\n\n // A Class to describe a \"doorbell\" (really a button)\n class Doorbell {\n     constructor(x_, y_, r_) {\n         // Location and size\n         this.x = x_;\n         this.y = y_;\n         this.r = r_;\n     }\n     // Is a point inside the doorbell? (used for mouse rollover, etc.)\n     contains(mx, my) {\n         return dist(mx, my, this.x, this.y) < this.r;\n     }\n     // Show the doorbell (hardcoded colors, could be improved)\n     display(mx, my) {\n         if (this.contains(mx, my)) {\n             fill(100);\n         } else {\n             fill(175);\n         }\n         stroke(0);\n         strokeWeight(4);\n         ellipseMode(RADIUS);\n         ellipse(this.x, this.y, this.r, this.r);\n     }\n }\n // A sound file object\n let dingdong;\n // A doorbell object (that will trigger the sound)\n let doorbell;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     // Load the sound file.\n\n     // We have included both an MP3 and an OGG version.\n     soundFormats('mp3', 'ogg');\n     dingdong = loadSound('assets/doorbell.mp3');\n     // Create a new doorbell\n     doorbell = new Doorbell(width / 2, height / 2, 32);\n }\n\n function draw() {\n     background(255);\n     // Show the doorbell\n     doorbell.display(mouseX, mouseY);\n }\n\n function mousePressed() {\n     // If the user clicks on the doorbell, play the sound!\n     if (doorbell.contains(mouseX, mouseY)) {\n         dingdong.play();\n     }\n }"
            },
            {
                "name": "Playback Rate",
                "description": "Load a SoundFile and map its playback rate to mouseY, volume to mouseX. Playback rate is the speed with which the web audio context processings the sound file information. Slower rates not only increase the duration of the sound, but also decrease the pitch because it is being played back at a slower frequency.\n\nTo run this example locally, you will need the p5.sound library a sound file, and a running local server.",
                "code": " // A sound file object\n let song;\n\n function preload() {\n     // Load a sound file\n     song = loadSound('assets/Damscray_DancingTiger.mp3');\n }\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     // Loop the sound forever\n\n     // (well, at least until stop() is called)\n     song.loop();\n }\n\n function draw() {\n     background(200);\n     // Set the volume to a range between 0 and 1.0\n     let volume = map(mouseX, 0, width, 0, 1);\n     volume = constrain(volume, 0, 1);\n     song.amp(volume);\n     // Set the rate to a range between 0.1 and 4\n\n     // Changing the rate alters the pitch\n     let speed = map(mouseY, 0.1, height, 0, 2);\n     speed = constrain(speed, 0.01, 4);\n     song.rate(speed);\n     // Draw some circles to show what is going on\n     stroke(0);\n     fill(51, 100);\n     ellipse(mouseX, 100, 48, 48);\n     stroke(0);\n     fill(51, 100);\n     ellipse(100, mouseY, 48, 48);\n }"
            },
            {
                "name": "Measuring Amplitude",
                "description": "Analyze the amplitude of sound with p5.Amplitude.\n\n*\n\nAmplitude is the magnitude of vibration. Sound is vibration, so its amplitude is is closely related to volume / loudness.\n\n*\n\nThe getLevel() method takes an array of amplitude values collected over a small period of time (1024 samples). Then it returns the Root Mean Square (RMS) of these values.\n\n*\n\nThe original amplitude values for digital audio are between -1.0 and 1.0. But the RMS will always be positive, because it is squared. And, rather than use instantanous amplitude readings that are sampled at a rate of 44,100 times per second, the RMS is an average over time (1024 samples, in this case), which better represents how we hear amplitude.\n\nTo run this example locally, you will need the p5.sound library a sound file, and a running local server.",
                "code": " let song, analyzer;\n\n function preload() {\n     song = loadSound('assets/lucky_dragons_-_power_melody.mp3');\n }\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     song.loop();\n     // create a new Amplitude analyzer\n     analyzer = new p5.Amplitude();\n     // Patch the input to an volume analyzer\n     analyzer.setInput(song);\n }\n\n function draw() {\n     background(255);\n     // Get the average (root mean square) amplitude\n     let rms = analyzer.getLevel();\n     fill(127);\n     stroke(0);\n     // Draw an ellipse with size based on volume\n     ellipse(width / 2, height / 2, 10 + rms * 200, 10 + rms * 200);\n }"
            },
            {
                "name": "Noise Drum Envelope",
                "description": "White Noise is a random audio signal with equal energy at every part of the frequency spectrum\n\n*\n\nAn Envelope is a series of fades, defined as time / value pairs.\n\n*\n\nIn this example, the p5.Env will be used to \"play\" the p5.Noise like a drum by controlling its output amplitude. A p5.Amplitude will get the level of all sound in the sketch, and we'll use this value to draw a green rectangle that shows the envelope in action.\n\nTo run this example locally, you will need the p5.sound library and a sound file.",
                "code": ""
            },
            {
                "name": "Note Envelope",
                "description": "An Envelope is a series of fades, defined as time / value pairs. In this example, the envelope will be used to \"play\" a note by controlling the output amplitude of an oscillator.\n\nThe p5.Oscillator sends its output through an internal Web Audio GainNode (p5.Oscillator.output). By default, that node has a constant value of 0.5. It can be reset with the osc.amp() method. Or, in this example, an Envelope takes control of that node, turning the amplitude up and down like a volume knob.\n\nTo run this example locally, you will need the p5.sound library and a sound file.",
                "code": " let osc, envelope, fft;\n let scaleArray = [60, 62, 64, 65, 67, 69, 71, 72];\n let note = 0;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     osc = new p5.SinOsc();\n     // Instantiate the envelope\n     envelope = new p5.Env();\n     // set attackTime, decayTime, sustainRatio, releaseTime\n     envelope.setADSR(0.001, 0.5, 0.1, 0.5);\n     // set attackLevel, releaseLevel\n     envelope.setRange(1, 0);\n     osc.start();\n     fft = new p5.FFT();\n     noStroke();\n }\n\n function draw() {\n     background(20);\n     if (frameCount % 60 === 0 || frameCount === 1) {\n         let midiValue = scaleArray[note];\n         let freqValue = midiToFreq(midiValue);\n         osc.freq(freqValue);\n         envelope.play(osc, 0, 0.1);\n         note = (note + 1) % scaleArray.length;\n     }\n     // plot FFT.analyze() frequency analysis on the canvas\n     let spectrum = fft.analyze();\n     for (let i = 0; i < spectrum.length / 20; i++) {\n         fill(spectrum[i], spectrum[i] / 10, 0);\n         let x = map(i, 0, spectrum.length / 20, 0, width);\n         let h = map(spectrum[i], 0, 255, 0, height);\n         rect(x, height, spectrum.length / 20, -h);\n     }\n }"
            },
            {
                "name": "Oscillator Frequency",
                "description": "Control an Oscillator and view the waveform using FFT. MouseX is mapped to frequency, mouseY is mapped to amplitude.\n\nTo run this example locally, you will need the p5.sound library and a sound file.",
                "code": " let osc, fft;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     osc = new p5.TriOsc();\n     // set frequency and type\n     osc.amp(0.5);\n     fft = new p5.FFT();\n     osc.start();\n }\n\n function draw() {\n     background(255);\n     let waveform = fft.waveform();\n     // analyze the waveform\n     beginShape();\n     strokeWeight(5);\n     for (let i = 0; i < waveform.length; i++) {\n         let x = map(i, 0, waveform.length, 0, width);\n         let y = map(waveform[i], -1, 1, height, 0);\n         vertex(x, y);\n     }\n     endShape();\n     // change oscillator frequency based on mouseX\n     let freq = map(mouseX, 0, width, 40, 880);\n     osc.freq(freq);\n     let amp = map(mouseY, 0, height, 1, 0.01);\n     osc.amp(amp);\n }"
            },
            {
                "name": "Mic Input",
                "description": "Get audio input from your computer's microphone. Make noise to float the ellipse.\n\nNote: p5.AudioIn contains its own p5.Amplitude object, so you can call getLevel on p5.AudioIn without creating a p5.Amplitude.\n\nTo run this example locally, you will need the p5.sound library and a running local server.",
                "code": ""
            },
            {
                "name": "Frequency Spectrum",
                "description": "Visualize the frequency spectrum of live audio input.\n\nTo run this example locally, you will need the p5.sound library and a running local server.",
                "code": " let mic, fft;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     noFill();\n     mic = new p5.AudioIn();\n     mic.start();\n     fft = new p5.FFT();\n     fft.setInput(mic);\n }\n\n function draw() {\n     background(200);\n     let spectrum = fft.analyze();\n     beginShape();\n     for (i = 0; i < spectrum.length; i++) {\n         vertex(i, map(spectrum[i], 0, 255, height, 0));\n     }\n     endShape();\n }"
            },
            {
                "name": "Mic Threshold",
                "description": "Trigger an event (draw a rectangle) when the Audio Input volume surpasses a threshold.\n\nTo run this example locally, you will need the p5.sound library and a running local server.",
                "code": " // Adapted from Learning Processing, Daniel Shiffman\n\n // learningprocessing.com\n let input;\n let analyzer;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     background(255);\n     // Create an Audio input\n     input = new p5.AudioIn();\n     input.start();\n }\n\n function draw() {\n     // Get the overall volume (between 0 and 1.0)\n     let volume = input.getLevel();\n     // If the volume > 0.1,  a rect is drawn at a random location.\n\n     // The louder the volume, the larger the rectangle.\n     let threshold = 0.1;\n     if (volume > threshold) {\n         stroke(0);\n         fill(0, 100);\n         rect(random(40, width), random(height), volume * 50, volume * 50);\n     }\n     // Graph the overall potential volume, w/ a line at the threshold\n     let y = map(volume, 0, 1, height, 0);\n     let ythreshold = map(threshold, 0, 1, height, 0);\n     noStroke();\n     fill(175);\n     rect(0, 0, 20, height);\n     // Then draw a rectangle on the graph, sized according to volume\n     fill(0);\n     rect(0, y, 20, y);\n     stroke(0);\n     line(0, ythreshold, 19, ythreshold);\n }"
            },
            {
                "name": "Filter LowPass",
                "description": "Apply a p5.LowPass filter to a p5.SoundFile. Visualize the sound with FFT. Map mouseX to the the filter's cutoff frequency and mouseY to resonance/width of the a BandPass filter *\n\nTo run this example locally, you will need the p5.sound library a sound file, and a running local server.",
                "code": " let soundFile;\n let fft;\n let filter, filterFreq, filterRes;\n\n function preload() {\n     soundFormats('mp3', 'ogg');\n     soundFile = loadSound('assets/beat');\n }\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     fill(255, 40, 255);\n     // loop the sound file\n     soundFile.loop();\n     filter = new p5.LowPass();\n     // Disconnect soundfile from master output.\n\n     // Then, connect it to the filter, so that we only hear the filtered sound\n     soundFile.disconnect();\n     soundFile.connect(filter);\n     fft = new p5.FFT();\n }\n\n function draw() {\n     background(30);\n     // Map mouseX to a the cutoff frequency from the lowest\n\n     // frequency (10Hz) to the highest (22050Hz) that humans can hear\n     filterFreq = map(mouseX, 0, width, 10, 22050);\n     // Map mouseY to resonance (volume boost) at the cutoff frequency\n     filterRes = map(mouseY, 0, height, 15, 5);\n     // set filter parameters\n     filter.set(filterFreq, filterRes);\n     // Draw every value in the FFT spectrum analysis where\n\n     // x = lowest (10Hz) to highest (22050Hz) frequencies,\n\n     // h = energy (amplitude / volume) at that frequency\n     let spectrum = fft.analyze();\n     noStroke();\n     for (let i = 0; i < spectrum.length; i++) {\n         let x = map(i, 0, spectrum.length, 0, width);\n         let h = -height + map(spectrum[i], 0, 255, height, 0);\n         rect(x, height, width / spectrum.length, h);\n     }\n }"
            },
            {
                "name": "Filter BandPass",
                "description": "Apply a p5.BandPass filter to white noise. Visualize the sound with FFT. Map mouseX to the bandpass frequency and mouseY to resonance/width of the a BandPass filter *\n\nTo run this example locally, you will need the p5.sound library a sound file, and a running local server.",
                "code": " let noise;\n let fft;\n let filter, filterFreq, filterWidth;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     fill(255, 40, 255);\n     filter = new p5.BandPass();\n     noise = new p5.Noise();\n     noise.disconnect();\n     // Disconnect soundfile from master output...\n     filter.process(noise);\n     // ...and connect to filter so we'll only hear BandPass.\n     noise.start();\n     fft = new p5.FFT();\n }\n\n function draw() {\n     background(30);\n     // Map mouseX to a bandpass freq from the FFT spectrum range: 10Hz - 22050Hz\n     filterFreq = map(mouseX, 0, width, 10, 22050);\n     // Map mouseY to resonance/width\n     filterWidth = map(mouseY, 0, height, 0, 90);\n     // set filter parameters\n     filter.set(filterFreq, filterWidth);\n     // Draw every value in the FFT spectrum analysis where\n\n     // x = lowest (10Hz) to highest (22050Hz) frequencies,\n\n     // h = energy / amplitude at that frequency\n     let spectrum = fft.analyze();\n     noStroke();\n     for (let i = 0; i < spectrum.length; i++) {\n         let x = map(i, 0, spectrum.length, 0, width);\n         let h = -height + map(spectrum[i], 0, 255, height, 0);\n         rect(x, height, width / spectrum.length, h);\n     }\n }"
            },
            {
                "name": "Delay",
                "description": "Click the mouse to hear the p5.Delay process a SoundFile. MouseX controls the p5.Delay Filter Frequency. MouseY controls both the p5.Delay Time and Resonance. Visualize the resulting sound's volume with an Amplitude object. *\n\nTo run this example locally, you will need the p5.sound library a sound file, and a running local server.",
                "code": " let soundFile, analyzer, delay;\n\n function preload() {\n     soundFormats('ogg', 'mp3');\n     soundFile = loadSound('assets/beatbox.mp3');\n }\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     soundFile.disconnect();\n     // so we'll only hear delay\n     delay = new p5.Delay();\n     delay.process(soundFile, 0.12, 0.7, 2300);\n     delay.setType('pingPong');\n     // a stereo effect\n     analyzer = new p5.Amplitude();\n }\n\n function draw() {\n     background(0);\n     // get volume reading from the p5.Amplitude analyzer\n     let level = analyzer.getLevel();\n     // use level to draw a green rectangle\n     let levelHeight = map(level, 0, 0.1, 0, height);\n     fill(100, 250, 100);\n     rect(0, height, width, -levelHeight);\n     let filterFreq = map(mouseX, 0, width, 60, 15000);\n     filterFreq = constrain(filterFreq, 60, 15000);\n     let filterRes = map(mouseY, 0, height, 3, 0.01);\n     filterRes = constrain(filterRes, 0.01, 3);\n     delay.filter(filterFreq, filterRes);\n     let delTime = map(mouseY, 0, width, 0.2, 0.01);\n     delTime = constrain(delTime, 0.01, 0.2);\n     delay.delayTime(delTime);\n }\n\n function mousePressed() {\n     soundFile.play();\n }"
            },
            {
                "name": "Reverb",
                "description": "Reverb gives depth and perceived space to a sound. Here, noise is processed with reverb. *\n\nTo run this example locally, you will need the p5.sound library a sound file, and a running local server.",
                "code": " let sound, reverb;\n\n function preload() {\n     soundFormats('mp3', 'ogg');\n     soundFile = loadSound('assets/Damscray_DancingTiger');\n     // disconnect the default connection\n\n     // so that we only hear the sound via the reverb.process\n     soundFile.disconnect();\n }\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     background(0);\n     reverb = new p5.Reverb();\n     // sonnects soundFile to reverb with a\n\n     // reverbTime of 6 seconds, decayRate of 0.2%\n     reverb.process(soundFile, 6, 0.2);\n     reverb.amp(4);\n     // turn it up!\n }\n\n function mousePressed() {\n     soundFile.play();\n }"
            },
            {
                "name": "Convolution Reverb",
                "description": "The p5.Convolver can recreate the sound of actual spaces using convolution. Convolution takes an Impulse Response, (the sound of a room reverberating), and uses that to recreate the sound of that space.\n\nClick to play a sound through convolution. Every time you click, the sound is convolved with a different Impulse Response. To hear the Impulse Response itself, press any key.\n\n*\n\nTo run this example locally, you will need the p5.sound library a sound file, and a running local server. These convolution samples are Creative Commons BY recordinghopkins",
                "code": " let sound, env, cVerb, fft;\n let currentIR = 0;\n let rawImpulse;\n\n function preload() {\n     // we have included both MP3 and OGG versions of all the impulses/sounds\n     soundFormats('ogg', 'mp3');\n     // create a p5.Convolver\n     cVerb = createConvolver('assets/bx-spring');\n     // add Impulse Responses to cVerb.impulses array, in addition to bx-spring\n     cVerb.addImpulse('assets/small-plate');\n     cVerb.addImpulse('assets/drum');\n     cVerb.addImpulse('assets/beatbox');\n     cVerb.addImpulse('assets/concrete-tunnel');\n     // load a sound that will be processed by the p5.ConvultionReverb\n     sound = loadSound('assets/Damscray_DancingTiger');\n }\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     rawImpulse = loadSound('assets/' + cVerb.impulses[currentIR].name);\n     // disconnect from master output...\n     sound.disconnect();\n     // ... and process with cVerb\n\n     // so that we only hear the reverb\n     cVerb.process(sound);\n     fft = new p5.FFT();\n }\n\n function draw() {\n     background(30);\n     fill(0, 255, 40);\n     let spectrum = fft.analyze();\n     // Draw every value in the frequencySpectrum array as a rectangle\n     noStroke();\n     for (let i = 0; i < spectrum.length; i++) {\n         let x = map(i, 0, spectrum.length, 0, width);\n         let h = -height + map(spectrum[i], 0, 255, height, 0);\n         rect(x, height, width / spectrum.length, h);\n     }\n }\n\n function mousePressed() {\n     // cycle through the array of cVerb.impulses\n     currentIR++;\n     if (currentIR >= cVerb.impulses.length) {\n         currentIR = 0;\n     }\n     cVerb.toggleImpulse(currentIR);\n     // play the sound through the impulse\n     sound.play();\n     // display the current Impulse Response name (the filepath)\n     println('Convolution Impulse Response: ' + cVerb.impulses[currentIR].name);\n     rawImpulse.setPath('assets/' + cVerb.impulses[currentIR].name);\n }\n // play the impulse (without convolution)\n function keyPressed() {\n     rawImpulse.play();\n }"
            },
            {
                "name": "Record Save Audio",
                "description": "Record a sound, play it back and save it as a .wav file to the client's computer. We need three objects: a p5.AudioIn (mic / sound source), p5.SoundRecorder (records the sound), and a p5.SoundFile (play back / save).\n\nTo run this example locally, you will need the p5.sound library a sound file, and a running local server.",
                "code": " let mic, recorder, soundFile;\n let state = 0;\n // mousePress will increment from Record, to Stop, to Play\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     background(200);\n     fill(0);\n     text('Enable mic and click the mouse to begin recording', 20, 20);\n     // create an audio in\n     mic = new p5.AudioIn();\n     // users must manually enable their browser microphone for recording to work properly!\n     mic.start();\n     // create a sound recorder\n     recorder = new p5.SoundRecorder();\n     // connect the mic to the recorder\n     recorder.setInput(mic);\n     // create an empty sound file that we will use to playback the recording\n     soundFile = new p5.SoundFile();\n }\n\n function mousePressed() {\n     // use the '.enabled' boolean to make sure user enabled the mic (otherwise we'd record silence)\n     if (state === 0 && mic.enabled) {\n         // Tell recorder to record to a p5.SoundFile which we will use for playback\n         recorder.record(soundFile);\n         background(255, 0, 0);\n         text('Recording now! Click to stop.', 20, 20);\n         state++;\n     } else if (state === 1) {\n         recorder.stop();\n         // stop recorder, and send the result to soundFile\n         background(0, 255, 0);\n         text('Recording stopped. Click to play & save', 20, 20);\n         state++;\n     } else if (state === 2) {\n         soundFile.play();\n         // play the result!\n         saveSound(soundFile, 'mySound.wav');\n         // save file\n         state++;\n     }\n }"
            },
            {
                "name": "Frequency Modulation",
                "description": "Frequency Modulation is a powerful form of synthesis. In its simplest form, FM involves two oscillators, referred to as the carrier and the modulator. As the modulator's waveform oscillates between some minimum and maximum amplitude value, that momentary value is added to (\"modulates\") the frequency of the carrier.\n\nThe carrier is typically set to oscillate at an audible frequency that we perceive as a pitch—in this case, it is a sine wave oscilaltor at 220Hz, equivalent to an \"A3\" note. The carrier is connected to master output by default (this is the case for all p5.Oscillators).\n\nWe will disconnect the modulator from master output, and instead connect to the frequency of the carrier: carrier.freq(modulator). This adds the output amplitude of the modulator to the frequency of the carrier.\n\nModulation Depth describes how much the carrier frequency will modulate. It is based on the amplitude of the modulator. The modulator produces a continuous stream of amplitude values that we will add to the carrier frequency. An amplitude of zero means silence, so the modulation will have no effect. An amplitude of 1.0 scales the range of output values between +1.0 and -1.0. That is the standard range for sound that gets sent to your speakers, but in FM we are instead sending the modulator's output to the carrier frequency, where we'd barely notice the +1Hz / -1Hz modulation. So we will typically increase the amplitude (\"depth\") of the modulator to numbers much higher than what we might send to our speakers.\n\nModulation Frequency is the speed of modulation. When the modulation frequency is lower than 20Hz, we stop hearing its frequency as pitch, and start to hear it as a beating rhythm. For example, try 7.5Hz at a depth of 20 to mimic the \"vibrato\" effect of an operatic vocalist. The term for this is Low Frequency Oscillator, or LFO. Modulators set to higher frequencies can also produce interesting effects, especially when the frequency has a harmonic relationship to the carrier signal. For example, listen to what happens when the modulator's frequency is half or twice that of the carrier. This is the basis for FM Synthesis, developed by John Chowning in the 1960s, which came to revolutionize synthesis in the 1980s and is often used to synthesize brass and bell-like sounds. *\n\nIn this example,\n\n- MouseX controls the modulation depth (the amplitude of the modulator) from -150 to 150. When the modulator's amplitude is set to 0 (in the middle), notice how the modulation has no effect. The greater (the absolute value of) the number, the greater the effect. If the modulator waveform is symetrical like a square [], sine ~ or triangle /\\, the negative amplitude will be the same as positive amplitude. But in this example, the modulator is an asymetrical sawtooth wave, shaped like this /. When we multiply it by a negative number, it goes backwards like this \\. To best observe the difference, try lowering the frequency.\n\n- MouseY controls the frequency of the modulator from 0 to 112 Hz. Try comparing modulation frequencies below the audible range (which starts around 20hz), and above it, especially in a harmonic relationship to the carrier frequency (which is 220hz, so try half that, 1/3, 1/4 etc...). *\n\nYou will need to include the p5.sound library for this example to work in your own project.",
                "code": " let carrier;\n // this is the oscillator we will hear\n let modulator;\n // this oscillator will modulate the frequency of the carrier\n let analyzer;\n // we'll use this visualize the waveform\n\n // the carrier frequency pre-modulation\n let carrierBaseFreq = 220;\n // min/max ranges for modulator\n let modMaxFreq = 112;\n let modMinFreq = 0;\n let modMaxDepth = 150;\n let modMinDepth = -150;\n\n function setup() {\n     let cnv = createCanvas(screenWidth, screenHeight);\n     noFill();\n     carrier = new p5.Oscillator('sine');\n     carrier.amp(0);\n     // set amplitude\n     carrier.freq(carrierBaseFreq);\n     // set frequency\n     carrier.start();\n     // start oscillating\n\n     // try changing the type to 'square', 'sine' or 'triangle'\n     modulator = new p5.Oscillator('sawtooth');\n     modulator.start();\n     // add the modulator's output to modulate the carrier's frequency\n     modulator.disconnect();\n     carrier.freq(modulator);\n     // create an FFT to analyze the audio\n     analyzer = new p5.FFT();\n     // fade carrier in/out on mouseover / touch start\n     toggleAudio(cnv);\n }\n\n function draw() {\n     background(30);\n     // map mouseY to modulator freq between a maximum and minimum frequency\n     let modFreq = map(mouseY, height, 0, modMinFreq, modMaxFreq);\n     modulator.freq(modFreq);\n     // change the amplitude of the modulator\n\n     // negative amp reverses the sawtooth waveform, and sounds percussive\n\n     //\n     let modDepth = map(mouseX, 0, width, modMinDepth, modMaxDepth);\n     modulator.amp(modDepth);\n     // analyze the waveform\n     waveform = analyzer.waveform();\n     // draw the shape of the waveform\n     stroke(255);\n     strokeWeight(10);\n     beginShape();\n     for (let i = 0; i < waveform.length; i++) {\n         let x = map(i, 0, waveform.length, 0, width);\n         let y = map(waveform[i], -1, 1, -height / 2, height / 2);\n         vertex(x, y + height / 2);\n     }\n     endShape();\n     strokeWeight(1);\n     // add a note about what's happening\n     text('Modulator Frequency: ' + modFreq.toFixed(3) + ' Hz', 20, 20);\n     text('Modulator Amplitude (Modulation Depth): ' + modDepth.toFixed(3), 20, 40);\n     text('Carrier Frequency (pre-modulation): ' + carrierBaseFreq + ' Hz', width / 2, 20);\n }\n // helper function to toggle sound\n function toggleAudio(cnv) {\n     cnv.mouseOver(function() {\n         carrier.amp(1.0, 0.01);\n     });\n     cnv.touchStarted(function() {\n         carrier.amp(1.0, 0.01);\n     });\n     cnv.mouseOut(function() {\n         carrier.amp(0.0, 1.0);\n     });\n }"
            },
            {
                "name": "Amplitude Modulation",
                "description": "Amplitude Modulation involves two oscillators, referred to as the carrier and the modulator, where the modulator controls the carrier's amplitude.\n\n*\n\nThe carrier is typically set at an audible frequency (i.e. 440 Hz) and connected to master output by default. The carrier.amp is set to zero because we will have the modulator control its amplitude.\n\n*\n\nThe modulator is disconnected from master output. Instead, it is connected to the amplitude of the Carrier, like this: carrier.amp(modulator).\n\n*\n\nIn this example...\n\n- MouseX controls the amplitude of the modulator from 0 to 1. When the modulator's amplitude is set to 0, the amplitude modulation has no effect.\n\n*\n\n- MouseY controls the frequency of the modulator from 0 to 20hz. This range is lower frequencies than humans can hear, and we perceive the modulation as a rhythm. This range can simulate effects such as Tremolo. Ring Modulation is a type of Amplitude Modulation where the original carrier signal is not present, and often involves modulation at a faster frequency.\n\n*\n\nYou will need to include the p5.sound library for this example to work in your own project.",
                "code": ""
            }
        ]
    },
    {
        "groupName": "Mobile",
        "examples": [
            {
                "name": "Acceleration Ball Bounce",
                "description": "Move an ellipse around based on accelerationX and accelerationY values, and bounces when touch the edge of the canvas.",
                "code": " // Position Variables\n let x = 0;\n let y = 0;\n // Speed - Velocity\n let vx = 0;\n let vy = 0;\n // Acceleration\n let ax = 0;\n let ay = 0;\n let vMultiplier = 0.007;\n let bMultiplier = 0.6;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     fill(0);\n }\n\n function draw() {\n     background(255);\n     ballMove();\n     ellipse(x, y, 30, 30);\n }\n\n function ballMove() {\n     ax = accelerationX;\n     ay = accelerationY;\n     vx = vx + ay;\n     vy = vy + ax;\n     y = y + vy * vMultiplier;\n     x = x + vx * vMultiplier;\n     // Bounce when touch the edge of the canvas\n     if (x < 0) {\n         x = 0;\n         vx = -vx * bMultiplier;\n     }\n     if (y < 0) {\n         y = 0;\n         vy = -vy * bMultiplier;\n     }\n     if (x > width - 20) {\n         x = width - 20;\n         vx = -vx * bMultiplier;\n     }\n     if (y > height - 20) {\n         y = height - 20;\n         vy = -vy * bMultiplier;\n     }\n }"
            },
            {
                "name": "Simple Draw",
                "description": "Touch to draw on the screen using mouseX, mouseY, pmouseX, and pmouseY values.",
                "code": " function setup() {\n     createCanvas(screenWidth, screenHeight);\n     strokeWeight(10);\n     stroke(0);\n }\n\n function touchMoved() {\n     line(mouseX, mouseY, pmouseX, pmouseY);\n     return false;\n }"
            },
            {
                "name": "Acceleration Color",
                "description": "Use deviceMoved() to detect when the device is rotated. The background RGB color values are mapped to accelerationX, accelerationY, and accelerationZ values.",
                "code": " let r, g, b;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     r = random(50, 255);\n     g = random(0, 200);\n     b = random(50, 255);\n }\n\n function draw() {\n     background(r, g, b);\n     console.log('draw');\n }\n\n function deviceMoved() {\n     r = map(accelerationX, -90, 90, 100, 175);\n     g = map(accelerationY, -90, 90, 100, 200);\n     b = map(accelerationZ, -90, 90, 100, 200);\n }"
            },
            {
                "name": "Shake Ball Bounce",
                "description": "Create a Ball class, instantiate multiple objects, move it around the screen, and bounce when touch the edge of the canvas. Detect shake event based on total change in accelerationX and accelerationY and speed up or slow down objects based on detection.",
                "code": ""
            },
            {
                "name": "Tilted 3D Box",
                "description": "Use mobile to tilt a box",
                "code": " function setup() {\n     createCanvas(screenWidth, screenHeight, WEBGL);\n }\n\n function draw() {\n     background(250);\n     normalMaterial();\n     rotateX(accelerationX * 0.01);\n     rotateY(accelerationY * 0.01);\n     box(100, 100, 100);\n }"
            }
        ]
    },
    {
        "groupName": "Hello p5",
        "examples": [
            {
                "name": "Simple Shapes",
                "description": "This examples includes a circle, square, triangle, and a flower.",
                "code": " function setup() {\n     // Create the canvas\n     createCanvas(screenWidth, screenHeight);\n     background(200);\n     // Set colors\n     fill(204, 101, 192, 127);\n     stroke(127, 63, 120);\n     // A rectangle\n     rect(40, 120, 120, 40);\n     // An ellipse\n     ellipse(240, 240, 80, 80);\n     // A triangle\n     triangle(300, 100, 320, 100, 310, 80);\n     // A design for a simple flower\n     translate(580, 200);\n     noStroke();\n     for (let i = 0; i < 10; i++) {\n         ellipse(0, 30, 20, 80);\n         rotate(PI / 5);\n     }\n }"
            },
            {
                "name": "Interactivity 1",
                "description": "The circle changes color when you click on it.",
                "code": " // for red, green, and blue color values\n let r, g, b;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     // Pick colors randomly\n     r = random(255);\n     g = random(255);\n     b = random(255);\n }\n\n function draw() {\n     background(127);\n     // Draw a circle\n     strokeWeight(2);\n     stroke(r, g, b);\n     fill(r, g, b, 127);\n     ellipse(360, 200, 200, 200);\n }\n // When the user clicks the mouse\n function mousePressed() {\n     // Check if mouse is inside the circle\n     let d = dist(mouseX, mouseY, 360, 200);\n     if (d < 100) {\n         // Pick new random color values\n         r = random(255);\n         g = random(255);\n         b = random(255);\n     }\n }"
            },
            {
                "name": "Interactivity 2",
                "description": "The circle changes color when you move the slider.",
                "code": " // A HTML range slider\n let slider;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     // hue, saturation, and brightness\n     colorMode(HSB, 255);\n     // slider has a range between 0 and 255 with a starting value of 127\n     slider = createSlider(0, 255, 127);\n }\n\n function draw() {\n     background(127);\n     strokeWeight(2);\n     // Set the hue according to the slider\n     stroke(slider.value(), 255, 255);\n     fill(slider.value(), 255, 255, 127);\n     ellipse(360, 200, 200, 200);\n }"
            },
            {
                "name": "Animation",
                "description": "The circle moves.",
                "code": ""
            },
            {
                "name": "Flocking",
                "description": "Demonstration of Craig Reynolds' \"Flocking\" behavior.\n(Rules: Cohesion, Separation, Alignment.)\nFrom natureofcode.com.",
                "code": " let boids = [];\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     // Add an initial set of boids into the system\n     for (let i = 0; i < 100; i++) {\n         boids[i] = new Boid(random(width), random(height));\n     }\n }\n\n function draw() {\n     background(51);\n     // Run all the boids\n     for (let i = 0; i < boids.length; i++) {\n         boids[i].run(boids);\n     }\n }\n // Boid class\n\n // Methods for Separation, Cohesion, Alignment added\n class Boid {\n     constructor(x, y) {\n         this.acceleration = createVector(0, 0);\n         this.velocity = p5.Vector.random2D();\n         this.position = createVector(x, y);\n         this.r = 3.0;\n         this.maxspeed = 3;\n         // Maximum speed\n         this.maxforce = 0.05;\n         // Maximum steering force\n     }\n     run(boids) {\n         this.flock(boids);\n         this.update();\n         this.borders();\n         this.render();\n     }\n     // Forces go into acceleration\n     applyForce(force) {\n         this.acceleration.add(force);\n     }\n     // We accumulate a new acceleration each time based on three rules\n     flock(boids) {\n         let sep = this.separate(boids);\n         // Separation\n         let ali = this.align(boids);\n         // Alignment\n         let coh = this.cohesion(boids);\n         // Cohesion\n\n         // Arbitrarily weight these forces\n         sep.mult(2.5);\n         ali.mult(1.0);\n         coh.mult(1.0);\n         // Add the force vectors to acceleration\n         this.applyForce(sep);\n         this.applyForce(ali);\n         this.applyForce(coh);\n     }\n     // Method to update location\n     update() {\n         // Update velocity\n         this.velocity.add(this.acceleration);\n         // Limit speed\n         this.velocity.limit(this.maxspeed);\n         this.position.add(this.velocity);\n         // Reset acceleration to 0 each cycle\n         this.acceleration.mult(0);\n     }\n     // A method that calculates and applies a steering force towards a target\n\n     // STEER = DESIRED MINUS VELOCITY\n     seek(target) {\n         let desired = p5.Vector.sub(target, this.position);\n         // A vector pointing from the location to the target\n\n         // Normalize desired and scale to maximum speed\n         desired.normalize();\n         desired.mult(this.maxspeed);\n         // Steering = Desired minus Velocity\n         let steer = p5.Vector.sub(desired, this.velocity);\n         steer.limit(this.maxforce);\n         // Limit to maximum steering force\n         return steer;\n     }\n     // Draw boid as a circle\n     render() {\n         fill(127, 127);\n         stroke(200);\n         ellipse(this.position.x, this.position.y, 16, 16);\n     }\n     // Wraparound\n     borders() {\n         if (this.position.x < -this.r) this.position.x = width + this.r;\n         if (this.position.y < -this.r) this.position.y = height + this.r;\n         if (this.position.x > width + this.r) this.position.x = -this.r;\n         if (this.position.y > height + this.r) this.position.y = -this.r;\n     }\n     // Separation\n\n     // Method checks for nearby boids and steers away\n     separate(boids) {\n         let desiredseparation = 25.0;\n         let steer = createVector(0, 0);\n         let count = 0;\n         // For every boid in the system, check if it's too close\n         for (let i = 0; i < boids.length; i++) {\n             let d = p5.Vector.dist(this.position, boids[i].position);\n             // If the distance is greater than 0 and less than an arbitrary amount (0 when you are yourself)\n             if ((d > 0) && (d < desiredseparation)) {\n                 // Calculate vector pointing away from neighbor\n                 let diff = p5.Vector.sub(this.position, boids[i].position);\n                 diff.normalize();\n                 diff.div(d);\n                 // Weight by distance\n                 steer.add(diff);\n                 count++;\n                 // Keep track of how many\n             }\n         }\n         // Average -- divide by how many\n         if (count > 0) {\n             steer.div(count);\n         }\n         // As long as the vector is greater than 0\n         if (steer.mag() > 0) {\n             // Implement Reynolds: Steering = Desired - Velocity\n             steer.normalize();\n             steer.mult(this.maxspeed);\n             steer.sub(this.velocity);\n             steer.limit(this.maxforce);\n         }\n         return steer;\n     }\n     // Alignment\n\n     // For every nearby boid in the system, calculate the average velocity\n     align(boids) {\n         let neighbordist = 50;\n         let sum = createVector(0, 0);\n         let count = 0;\n         for (let i = 0; i < boids.length; i++) {\n             let d = p5.Vector.dist(this.position, boids[i].position);\n             if ((d > 0) && (d < neighbordist)) {\n                 sum.add(boids[i].velocity);\n                 count++;\n             }\n         }\n         if (count > 0) {\n             sum.div(count);\n             sum.normalize();\n             sum.mult(this.maxspeed);\n             let steer = p5.Vector.sub(sum, this.velocity);\n             steer.limit(this.maxforce);\n             return steer;\n         } else {\n             return createVector(0, 0);\n         }\n     }\n     // Cohesion\n\n     // For the average location (i.e. center) of all nearby boids, calculate steering vector towards that location\n     cohesion(boids) {\n         let neighbordist = 50;\n         let sum = createVector(0, 0);\n         // Start with empty vector to accumulate all locations\n         let count = 0;\n         for (let i = 0; i < boids.length; i++) {\n             let d = p5.Vector.dist(this.position, boids[i].position);\n             if ((d > 0) && (d < neighbordist)) {\n                 sum.add(boids[i].position);\n                 // Add location\n                 count++;\n             }\n         }\n         if (count > 0) {\n             sum.div(count);\n             return this.seek(sum);\n             // Steer towards the location\n         } else {\n             return createVector(0, 0);\n         }\n     }\n }"
            },
            {
                "name": "Weather",
                "description": "This example grabs JSON weather data from www.metaweather.com.",
                "code": " // A wind direction vector\n let wind;\n // Circle position\n let position;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     // Request the data from metaweather.com\n     let url = 'https://cors-anywhere.herokuapp.com/https://www.metaweather.com/api/location/2459115/';\n     loadJSON(url, gotWeather);\n     // Circle starts in the middle\n     position = createVector(width / 2, height / 2);\n     // wind starts as (0,0)\n     wind = createVector();\n }\n\n function draw() {\n     background(200);\n     // This section draws an arrow pointing in the direction of wind\n     push();\n     translate(32, height - 32);\n     // Rotate by the wind's angle\n     rotate(wind.heading() + PI / 2);\n     noStroke();\n     fill(255);\n     ellipse(0, 0, 48, 48);\n     stroke(45, 123, 182);\n     strokeWeight(3);\n     line(0, -16, 0, 16);\n     noStroke();\n     fill(45, 123, 182);\n     triangle(0, -18, -6, -10, 6, -10);\n     pop();\n     // Move in the wind's direction\n     position.add(wind);\n     stroke(0);\n     fill(51);\n     ellipse(position.x, position.y, 16, 16);\n     if (position.x > width) position.x = 0;\n     if (position.x < 0) position.x = width;\n     if (position.y > height) position.y = 0;\n     if (position.y < 0) position.y = height;\n }\n\n function gotWeather(weather) {\n     let weather_today = weather.consolidated_weather[0]\n     // Get the angle (convert to radians)\n     let angle = radians(Number(weather_today.wind_direction));\n     // Get the wind speed\n     let windmag = Number(weather_today.wind_speed);\n     // Display as HTML elements\n     let temperatureDiv = createDiv(floor(weather_today.the_temp) + '&deg;C');\n     let windDiv = createDiv(\"WIND \" + windmag + \" <small>MPH</small>\");\n     // Make a vector\n     wind = p5.Vector.fromAngle(angle);\n }"
            },
            {
                "name": "Drawing",
                "description": "Generative painting program.",
                "code": " // All the paths\n let paths = [];\n // Are we painting?\n let painting = false;\n // How long until the next circle\n let next = 0;\n // Where are we now and where were we?\n let current;\n let previous;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     current = createVector(0, 0);\n     previous = createVector(0, 0);\n };\n\n function draw() {\n     background(200);\n     // If it's time for a new point\n     if (millis() > next && painting) {\n         // Grab mouse position      \n         current.x = mouseX;\n         current.y = mouseY;\n         // New particle's force is based on mouse movement\n         let force = p5.Vector.sub(current, previous);\n         force.mult(0.05);\n         // Add new particle\n         paths[paths.length - 1].add(current, force);\n         // Schedule next circle\n         next = millis() + random(100);\n         // Store mouse values\n         previous.x = current.x;\n         previous.y = current.y;\n     }\n     // Draw all paths\n     for (let i = 0; i < paths.length; i++) {\n         paths[i].update();\n         paths[i].display();\n     }\n }\n // Start it up\n function mousePressed() {\n     next = 0;\n     painting = true;\n     previous.x = mouseX;\n     previous.y = mouseY;\n     paths.push(new Path());\n }\n // Stop\n function mouseReleased() {\n     painting = false;\n }\n // A Path is a list of particles\n class Path {\n     constructor() {\n         this.particles = [];\n         this.hue = random(100);\n     }\n     add(position, force) {\n         // Add a new particle with a position, force, and hue\n         this.particles.push(new Particle(position, force, this.hue));\n     }\n     // Display plath\n     update() {\n         for (let i = 0; i < this.particles.length; i++) {\n             this.particles[i].update();\n         }\n     }\n     // Display plath\n     display() {\n         // Loop through backwards\n         for (let i = this.particles.length - 1; i >= 0; i--) {\n             // If we shold remove it\n             if (this.particles[i].lifespan <= 0) {\n                 this.particles.splice(i, 1);\n                 // Otherwise, display it\n             } else {\n                 this.particles[i].display(this.particles[i + 1]);\n             }\n         }\n     }\n }\n // Particles along the path\n class Particle {\n     constructor(position, force, hue) {\n         this.position = createVector(position.x, position.y);\n         this.velocity = createVector(force.x, force.y);\n         this.drag = 0.95;\n         this.lifespan = 255;\n     }\n     update() {\n         // Move it\n         this.position.add(this.velocity);\n         // Slow it down\n         this.velocity.mult(this.drag);\n         // Fade it out\n         this.lifespan--;\n     }\n     // Draw particle and connect it with a line\n\n     // Draw a line to another\n     display(other) {\n         stroke(0, this.lifespan);\n         fill(0, this.lifespan / 2);\n         ellipse(this.position.x, this.position.y, 8, 8);\n         // If we need to draw a line\n         if (other) {\n             line(this.position.x, this.position.y, other.position.x, other.position.y);\n         }\n     }\n }"
            },
            {
                "name": "Song",
                "description": "Play a song. You will need to include the p5.sound library for this example to work in your own project.",
                "code": " // The midi notes of a scale\n let notes = [60, 62, 64, 65, 67, 69, 71];\n // For automatically playing the song\n let index = 0;\n let song = [{\n     note: 4,\n     duration: 400,\n     display: \"D\"\n }, {\n     note: 0,\n     duration: 200,\n     display: \"G\"\n }, {\n     note: 1,\n     duration: 200,\n     display: \"A\"\n }, {\n     note: 2,\n     duration: 200,\n     display: \"B\"\n }, {\n     note: 3,\n     duration: 200,\n     display: \"C\"\n }, {\n     note: 4,\n     duration: 400,\n     display: \"D\"\n }, {\n     note: 0,\n     duration: 400,\n     display: \"G\"\n }, {\n     note: 0,\n     duration: 400,\n     display: \"G\"\n }];\n let trigger = 0;\n let autoplay = false;\n let osc;\n\n function setup() {\n     createCanvas(screenWidth, screenHeight);\n     let div = createDiv(\"Click to play notes or \") div.id(\"instructions\");\n     let button = createButton(\"play song automatically.\");\n     button.parent(\"instructions\");\n     // Trigger automatically playing\n     button.mousePressed(function() {\n         if (!autoplay) {\n             index = 0;\n             autoplay = true;\n         }\n     });\n     // A triangle oscillator\n     osc = new p5.TriOsc();\n     // Start silent\n     osc.start();\n     osc.amp(0);\n }\n // A function to play a note\n function playNote(note, duration) {\n     osc.freq(midiToFreq(note));\n     // Fade it in\n     osc.fade(0.5, 0.2);\n     // If we sest a duration, fade it out\n     if (duration) {\n         setTimeout(function() {\n             osc.fade(0, 0.2);\n         }, duration - 50);\n     }\n }\n\n function draw() {\n     // If we are autoplaying and it's time for the next note\n     if (autoplay && millis() > trigger) {\n         playNote(notes[song[index].note], song[index].duration);\n         trigger = millis() + song[index].duration;\n         // Move to the next note\n         index++;\n         // We're at the end, stop autoplaying.\n     } else if (index >= song.length) {\n         autoplay = false;\n     }\n     // Draw a keyboard\n\n     // The width for each key\n     let w = width / notes.length;\n     for (let i = 0; i < notes.length; i++) {\n         let x = i * w;\n         // If the mouse is over the key\n         if (mouseX > x && mouseX < x + w && mouseY < height) {\n             // If we're clicking\n             if (mouseIsPressed) {\n                 fill(100, 255, 200);\n                 // Or just rolling over\n             } else {\n                 fill(127);\n             }\n         } else {\n             fill(200);\n         }\n         // Or if we're playing the song, let's highlight it too\n         if (autoplay && i === song[index - 1].note) {\n             fill(100, 255, 200);\n         }\n         // Draw the key\n         rect(x, 0, w - 1, height - 1);\n     }\n }\n // When we click\n function mousePressed(event) {\n     if (event.button == 0 && event.clientX < width && event.clientY < height) {\n         // Map mouse to the key index\n         let key = floor(map(mouseX, 0, width, 0, notes.length));\n         playNote(notes[key]);\n     }\n }\n // Fade it out when we release\n function mouseReleased() {\n     osc.fade(0, 0.5);\n }"
            }
        ]
    }
]